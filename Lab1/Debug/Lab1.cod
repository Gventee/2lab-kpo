; Listing generated by Microsoft (R) Optimizing Compiler Version 19.42.34435.0 

	TITLE	C:\Users\gvent\OneDrive\Desktop\KPO\Lab1\Lab1\Debug\Lab1.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__3A77C584_concurrencysal@h DB 01H
__7D61E6FE_sal@h DB 01H
__F85DFF2E_vadefs@h DB 01H
__E62C82FD_vcruntime@h DB 01H
__02F1C7E0_xkeycheck@h DB 01H
__0731AE6E_yvals_core@h DB 01H
__1B0272D9_corecrt@h DB 01H
__B9985323_float@h DB 01H
__1C7C89ED_cfloat DB 01H
__3E26BF77_limits@h DB 01H
__DACAF7EF_climits DB 01H
__BCF39F11_vcruntime_new@h DB 01H
__86CDF331_vcruntime_new_debug@h DB 01H
__935DC21B_crtdbg@h DB 01H
__C5864FDA_crtdefs@h DB 01H
__7A030B0F_use_ansi@h DB 01H
__E86563A2_yvals@h DB 01H
__BB16330F_corecrt_math@h DB 01H
__3BF2A406_math@h DB 01H
__45DED006_corecrt_malloc@h DB 01H
__13F5961F_stddef@h DB 01H
__FD6DBD68_corecrt_search@h DB 01H
__E2E33A61_corecrt_wstdlib@h DB 01H
__6E5ACABA_stdlib@h DB 01H
__5E25D51D_cstdlib DB 01H
__810D3946_xtr1common DB 01H
__020D51C1_intrin0@inl@h DB 01H
__DCABF6D1_intrin0@h DB 01H
__1FDBE849_cmath DB 01H
__44420885_corecrt_stdio_config@h DB 01H
__AB601D8D_corecrt_wstdio@h DB 01H
__C1EC35D3_stdio@h DB 01H
__6F38426A_cstdio DB 01H
__61CC25A1_errno@h DB 01H
__731D38DD_vcruntime_string@h DB 01H
__E4C945B4_corecrt_memcpy_s@h DB 01H
__8EAFF484_corecrt_memory@h DB 01H
__6490AEC5_corecrt_wstring@h DB 01H
__E8295E1E_string@h DB 01H
__12B77DFD_cstring DB 01H
__EF1F6BBA_corecrt_wconio@h DB 01H
__74484FB3_corecrt_wctype@h DB 01H
__3D1D430C_corecrt_wdirect@h DB 01H
__8ECB7138_corecrt_share@h DB 01H
__DB7FEBA6_corecrt_wio@h DB 01H
__9A9F0068_corecrt_wprocess@h DB 01H
__369A9BC3_corecrt_wtime@h DB 01H
__CE789B9D_types@h DB 01H
__9901C817_stat@h DB 01H
__3FCAD62E_wchar@h DB 01H
__F5B39439_cwchar DB 01H
__B673110F_iosfwd DB 01H
__FBEE0FB0_cstddef DB 01H
__20B1B3B7_initializer_list DB 01H
__80509148_stdint@h DB 01H
__E37B3460_cstdint DB 01H
__4C58012B_type_traits DB 01H
__69285096_utility DB 01H
__9DF8D3B1___msvc_iter_core@hpp DB 01H
__EC88E9B5_xutility DB 01H
__FD245EF5_iterator DB 01H
__F7972D0B_share@h DB 01H
__CB3B79BB___msvc_system_error_abi@hpp DB 01H
__F2193691_cerrno DB 01H
__FA77ED4C_malloc@h DB 01H
__89766DA4_corecrt_terminate@h DB 01H
__412BB509_eh@h DB 01H
__8E23F663_vcruntime_exception@h DB 01H
__0DD9214C_exception DB 01H
__F8F3CAFF___msvc_sanitizer_annotate_container@hpp DB 01H
__39B162D3___msvc_string_view@hpp DB 01H
__7A9AC489_limits DB 01H
__8483113F_new DB 01H
__07D5AD9A_xatomic@h DB 01H
__03BD3355_xmemory DB 01H
__776EB5C9_xstring DB 01H
__84971B11_stdexcept DB 01H
__44A9703E_xcall_once@h DB 01H
__40F076AD_xerrc@h DB 01H
__5F635487___msvc_threads_core@hpp DB 01H
__0A9237D2_time@h DB 01H
__D9687441_ctime DB 01H
__5A4C0AF4_xtimec@h DB 01H
__1B4D3CBC_xthreads@h DB 01H
__11AF984B_atomic DB 01H
__FBF4621E_system_error DB 01H
__8916352E_vcruntime_typeinfo@h DB 01H
__9C571AAC_typeinfo DB 01H
__C634C807_memory DB 01H
__EA719F08_xfacet DB 01H
__0FD15498___msvc_xlocinfo_types@hpp DB 01H
__1EC467ED_ctype@h DB 01H
__60F3A5CD_cctype DB 01H
__791C33B7_locale@h DB 01H
__CD8909CC_clocale DB 01H
__83DEF964_xlocinfo DB 01H
__A850C1F8_xlocale DB 01H
__BA3B8E77_xiosbase DB 01H
__8637A3AD_streambuf DB 01H
__36D7A7EF_xlocnum DB 01H
__7C4E2B29_ios DB 01H
__BB401B3C_ostream DB 01H
__D8902E06_istream DB 01H
__8EF193AA_iostream DB 01H
__B2E74E9B_string DB 01H
__1DB5B2D7_xlocmon DB 01H
__27C35076_xloctime DB 01H
__2452E854_iomanip DB 01H
__1B3EED86_sstream DB 01H
__B7C10C64_stdafx@h DB 01H
__8ED5CA96_YearUtils@h DB 01H
__7275DC2C_DateUtils@h DB 01H
__73401638_ValidDate@h DB 01H
__FFBC5EC9_MonthUtils@h DB 01H
__490706C5_Lab1@cpp DB 01H
msvcjmc	ENDS
CONST	SEGMENT
?_Valid_strftime_specifiers@std@@3QBDB DB 061H		; std::_Valid_strftime_specifiers
	DB	041H
	DB	062H
	DB	042H
	DB	063H
	DB	043H
	DB	064H
	DB	044H
	DB	065H
	DB	046H
	DB	067H
	DB	047H
	DB	068H
	DB	048H
	DB	049H
	DB	06aH
	DB	06dH
	DB	04dH
	DB	06eH
	DB	070H
	DB	072H
	DB	052H
	DB	053H
	DB	074H
	DB	054H
	DB	075H
	DB	055H
	DB	056H
	DB	077H
	DB	057H
	DB	078H
	DB	058H
	DB	079H
	DB	059H
	DB	07aH
	DB	05aH
CONST	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	_wmemcpy
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	_main
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
PUBLIC	??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Deallocate@$07@std@@YAXPAXI@Z		; std::_Deallocate<8>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
PUBLIC	??$_Max_limit@H@std@@YAHXZ			; std::_Max_limit<int>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0GC@LEHJKL@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	?__LINE__Var@?0??_Maklocwcs@std@@YAPA_WPB_W@Z@4JA ; `std::_Maklocwcs'::`1'::__LINE__Var
PUBLIC	??_C@_0GC@IDPJHLAK@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_03EEFOAFAG@RUS@				; `string'
PUBLIC	??_C@_0CC@GJFPIFCJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?D?D?L?L?C?C?C?C@ ; `string'
PUBLIC	??_C@_0DF@KJIHCF@?N?x?h?a?j?$OA?3?5?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?d?$OA?r?$PL?5?h?k@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_07ONJDPLPB@?L?e?q?$PP?v?3?5@		; `string'
PUBLIC	??_C@_0BL@DHNAMEDH@?5?c?n?d?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@ ; `string'
PUBLIC	??_C@_0BO@CADEGJDO@?5?c?n?d?5?m?e?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@ ; `string'
PUBLIC	??_C@_0BO@CMHEMFCG@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?b?5?c?n?d?s?3?5@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0CB@JCCKEGFO@?D?$OA?r?$OA?5?o?n?5?o?n?p?$PP?d?j?n?b?n?l?s?5?m?n?l?e?p?s?5?d?m?$PP?3@ ; `string'
PUBLIC	??_C@_0BH@MOBCIPFF@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?$CI?D?D?5?L?L?$CJ?3?5@ ; `string'
PUBLIC	??_C@_0CK@EAGMMNGG@?N?x?h?a?j?$OA?$CB?5?B?b?e?d?h?r?e?5?j?n?p?p?e?j?r?m?s?$PO?5?d?$OA?r?s@ ; `string'
PUBLIC	??_C@_0CC@DHIPJDDH@?D?m?e?i?5?d?n?5?a?k?h?f?$OA?i?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP@ ; `string'
PUBLIC	??_C@_0FF@BMJFHHK@?B?b?e?d?h?r?e?5?o?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?c?n@ ; `string'
PUBLIC	??_C@_0P@JLLDJCIK@?D?$OA?r?$OA?5?q?n?a?$PL?r?h?$PP?3?5@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp__setlocale:PROC
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_??Bid@locale@std@@QAEIXZ:PROC
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	__imp_?is@?$ctype@D@std@@QBE_NFD@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:PROC
EXTRN	__imp_??7ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z:PROC
EXTRN	__imp_?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z:PROC
EXTRN	?isLeapYear@YearUtils@@YA_NH@Z:PROC		; YearUtils::isLeapYear
EXTRN	?dayOfYear@DateUtils@@YAHHHH@Z:PROC		; DateUtils::dayOfYear
EXTRN	?daysUntilBirthday@DateUtils@@YAHHHHHH@Z:PROC	; DateUtils::daysUntilBirthday
EXTRN	?parseDate@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH11@Z:PROC ; parseDate
EXTRN	?isValidDate@@YA_NHH@Z:PROC			; isValidDate
EXTRN	?getMonthName@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:PROC ; getMonthName
EXTRN	?getDateFromDayNumber@@YAXHHAAH0@Z:PROC		; getDateFromDayNumber
EXTRN	?getEventDate@@YAXHHAAH0@Z:PROC			; getEventDate
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:DWORD
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JLLDJCIK@?D?$OA?r?$OA?5?q?n?a?$PL?r?h?$PP?3?5@
CONST	SEGMENT
??_C@_0P@JLLDJCIK@?D?$OA?r?$OA?5?q?n?a?$PL?r?h?$PP?3?5@ DB 0c4H, 0e0H, 0f2H
	DB	0e0H, ' ', 0f1H, 0eeH, 0e1H, 0fbH, 0f2H, 0e8H, 0ffH, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FF@BMJFHHK@?B?b?e?d?h?r?e?5?o?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?c?n@
CONST	SEGMENT
??_C@_0FF@BMJFHHK@?B?b?e?d?h?r?e?5?o?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?c?n@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0efH, 0eeH, 0f0H, 0ffH
	DB	0e4H, 0eaH, 0eeH, 0e2H, 0fbH, 0e9H, ' ', 0edH, 0eeH, 0ecH, 0e5H
	DB	0f0H, ' ', 0e4H, 0edH, 0ffH, ' ', 0e3H, 0eeH, 0e4H, 0e0H, ' ', 0e4H
	DB	0ebH, 0ffH, ' ', 0f1H, 0eeH, 0e1H, 0fbH, 0f2H, 0e8H, 0ffH, ' ('
	DB	0edH, 0e0H, 0efH, 0f0H, 0e8H, 0ecH, 0e5H, 0f0H, ', 256 ', 0e4H
	DB	0ebH, 0ffH, ' ', 0c4H, 0edH, 0ffH, ' ', 0efH, 0f0H, 0eeH, 0e3H
	DB	0f0H, 0e0H, 0ecH, 0ecH, 0e8H, 0f1H, 0f2H, 0e0H, '): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DHIPJDDH@?D?m?e?i?5?d?n?5?a?k?h?f?$OA?i?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP@
CONST	SEGMENT
??_C@_0CC@DHIPJDDH@?D?m?e?i?5?d?n?5?a?k?h?f?$OA?i?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP@ DB 0c4H
	DB	0edH, 0e5H, 0e9H, ' ', 0e4H, 0eeH, ' ', 0e1H, 0ebH, 0e8H, 0e6H
	DB	0e0H, 0e9H, 0f8H, 0e5H, 0e3H, 0eeH, ' ', 0e4H, 0edH, 0ffH, ' ', 0f0H
	DB	0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@EAGMMNGG@?N?x?h?a?j?$OA?$CB?5?B?b?e?d?h?r?e?5?j?n?p?p?e?j?r?m?s?$PO?5?d?$OA?r?s@
CONST	SEGMENT
??_C@_0CK@EAGMMNGG@?N?x?h?a?j?$OA?$CB?5?B?b?e?d?h?r?e?5?j?n?p?p?e?j?r?m?s?$PO?5?d?$OA?r?s@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, '! ', 0c2H, 0e2H, 0e5H, 0e4H, 0e8H
	DB	0f2H, 0e5H, ' ', 0eaH, 0eeH, 0f0H, 0f0H, 0e5H, 0eaH, 0f2H, 0edH
	DB	0f3H, 0feH, ' ', 0e4H, 0e0H, 0f2H, 0f3H, ' (', 0c4H, 0c4H, ' ', 0ccH
	DB	0ccH, '): ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@MOBCIPFF@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?$CI?D?D?5?L?L?$CJ?3?5@
CONST	SEGMENT
??_C@_0BH@MOBCIPFF@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?$CI?D?D?5?L?L?$CJ?3?5@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H, 0f2H, 0f3H
	DB	' (', 0c4H, 0c4H, ' ', 0ccH, 0ccH, '): ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@JCCKEGFO@?D?$OA?r?$OA?5?o?n?5?o?n?p?$PP?d?j?n?b?n?l?s?5?m?n?l?e?p?s?5?d?m?$PP?3@
CONST	SEGMENT
??_C@_0CB@JCCKEGFO@?D?$OA?r?$OA?5?o?n?5?o?n?p?$PP?d?j?n?b?n?l?s?5?m?n?l?e?p?s?5?d?m?$PP?3@ DB 0c4H
	DB	0e0H, 0f2H, 0e0H, ' ', 0efH, 0eeH, ' ', 0efH, 0eeH, 0f0H, 0ffH
	DB	0e4H, 0eaH, 0eeH, 0e2H, 0eeH, 0ecH, 0f3H, ' ', 0edH, 0eeH, 0ecH
	DB	0e5H, 0f0H, 0f3H, ' ', 0e4H, 0edH, 0ffH, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CMHEMFCG@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?b?5?c?n?d?s?3?5@
CONST	SEGMENT
??_C@_0BO@CMHEMFCG@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?b?5?c?n?d?s?3?5@ DB 0cfH
	DB	0eeH, 0f0H, 0ffH, 0e4H, 0eaH, 0eeH, 0e2H, 0fbH, 0e9H, ' ', 0edH
	DB	0eeH, 0ecH, 0e5H, 0f0H, ' ', 0e4H, 0edH, 0ffH, ' ', 0e2H, ' ', 0e3H
	DB	0eeH, 0e4H, 0f3H, ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CADEGJDO@?5?c?n?d?5?m?e?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@
CONST	SEGMENT
??_C@_0BO@CADEGJDO@?5?c?n?d?5?m?e?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@ DB ' '
	DB	0e3H, 0eeH, 0e4H, ' ', 0edH, 0e5H, ' ', 0ffH, 0e2H, 0ebH, 0ffH
	DB	0e5H, 0f2H, 0f1H, 0ffH, ' ', 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH
	DB	0f1H, 0edH, 0fbH, 0ecH, '.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@DHNAMEDH@?5?c?n?d?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@
CONST	SEGMENT
??_C@_0BL@DHNAMEDH@?5?c?n?d?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@ DB ' '
	DB	0e3H, 0eeH, 0e4H, ' ', 0ffH, 0e2H, 0ebH, 0ffH, 0e5H, 0f2H, 0f1H
	DB	0ffH, ' ', 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH, 0fbH
	DB	0ecH, '.', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07ONJDPLPB@?L?e?q?$PP?v?3?5@
CONST	SEGMENT
??_C@_07ONJDPLPB@?L?e?q?$PP?v?3?5@ DB 0ccH, 0e5H, 0f1H, 0ffH, 0f6H, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@KJIHCF@?N?x?h?a?j?$OA?3?5?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?d?$OA?r?$PL?5?h?k@
CONST	SEGMENT
??_C@_0DF@KJIHCF@?N?x?h?a?j?$OA?3?5?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?d?$OA?r?$PL?5?h?k@ DB 0ceH
	DB	0f8H, 0e8H, 0e1H, 0eaH, 0e0H, ': ', 0cdH, 0e5H, 0e2H, 0e5H, 0f0H
	DB	0edH, 0fbH, 0e9H, ' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e0H, 0f2H, ' ', 0e4H
	DB	0e0H, 0f2H, 0fbH, ' ', 0e8H, 0ebH, 0e8H, ' ', 0edH, 0e5H, 0e4H
	DB	0eeH, 0efH, 0f3H, 0f1H, 0f2H, 0e8H, 0ecH, 0e0H, 0ffH, ' ', 0e4H
	DB	0e0H, 0f2H, 0e0H, '.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GJFPIFCJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?D?D?L?L?C?C?C?C@
CONST	SEGMENT
??_C@_0CC@GJFPIFCJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?D?D?L?L?C?C?C?C@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H, 0f2H, 0f3H
	DB	' ', 0e2H, ' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e0H, 0f2H, 0e5H, ' ', 0c4H
	DB	0c4H, 0ccH, 0ccH, 0c3H, 0c3H, 0c3H, 0c3H, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03EEFOAFAG@RUS@
CONST	SEGMENT
??_C@_03EEFOAFAG@RUS@ DB 'RUS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@IDPJHLAK@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@IDPJHLAK@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'42.34433\include\xlocnum', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Maklocwcs@std@@YAPA_WPB_W@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Maklocwcs@std@@YAPA_WPB_W@Z@4JA DD 049H ; `std::_Maklocwcs'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_0GC@LEHJKL@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@LEHJKL@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program Fil'
	DB	'es\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42'
	DB	'.34433\include\xlocale', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '4', 00H, '2', 00H, '.', 00H, '3', 00H, '4', 00H, '4'
	DB	00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'42.34433\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 0a9H ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	0392H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0
__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$3
__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	015bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	02eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	0351H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4
__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	031H
	DW	03feH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	037H
	DB	044H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0580H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	00H
	DD	FLAT:__unwindfunclet$_main$2
	DD	00H
	DD	FLAT:__unwindfunclet$_main$3
__ehfuncinfo$_main DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	028H
	DB	035H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	030H
	DW	0182H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	025H
	DW	016aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	091H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	0aeH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	093H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	07aH
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00026	c6 45 fb 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 90   : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -32						; size = 4
__Ptr_container$ = -20					; size = 4
__Block_size$ = -8					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 151  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 152  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	83 c0 27	 add	 eax, 39			; 00000027H
  0002c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 154  :     if (_Block_size <= _Bytes) {

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00032	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00035	77 06		 ja	 SHORT $LN8@Allocate_m

; 155  :         _Throw_bad_array_new_length(); // add overflow

  00037	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0003c	90		 npad	 1
$LN8@Allocate_m:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 ec	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004c	83 7d ec 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00050	74 02		 je	 SHORT $LN9@Allocate_m
  00052	eb 5d		 jmp	 SHORT $LN6@Allocate_m
$LN9@Allocate_m:
  00054	8b f4		 mov	 esi, esp
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00060	6a 00		 push	 0
  00062	68 9f 00 00 00	 push	 159			; 0000009fH
  00067	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@
  0006c	6a 02		 push	 2
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00074	83 c4 18	 add	 esp, 24			; 00000018H
  00077	3b f4		 cmp	 esi, esp
  00079	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007e	83 f8 01	 cmp	 eax, 1
  00081	75 01		 jne	 SHORT $LN12@Allocate_m
  00083	cc		 int	 3
$LN12@Allocate_m:
  00084	8b f4		 mov	 esi, esp
  00086	6a 00		 push	 0
  00088	68 9f 00 00 00	 push	 159			; 0000009fH
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00092	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	90		 npad	 1
  000ad	33 c0		 xor	 eax, eax
  000af	75 a3		 jne	 SHORT $LN9@Allocate_m
$LN6@Allocate_m:
  000b1	33 c0		 xor	 eax, eax
  000b3	75 97		 jne	 SHORT $LN4@Allocate_m

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000b5	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000b8	83 c0 27	 add	 eax, 39			; 00000027H
  000bb	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000be	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000c1	b8 04 00 00 00	 mov	 eax, 4
  000c6	6b c8 ff	 imul	 ecx, eax, -1
  000c9	8b 55 e0	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000cc	8b 45 ec	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000cf	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 162  : 
; 163  : #ifdef _DEBUG
; 164  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000d2	b8 04 00 00 00	 mov	 eax, 4
  000d7	6b c8 fe	 imul	 ecx, eax, -2
  000da	8b 55 e0	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000dd	c7 04 0a fa fa
	fa fa		 mov	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH

; 165  : #endif // defined(_DEBUG)
; 166  :     return _Ptr;

  000e4	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN1@Allocate_m:

; 167  : }

  000e7	5f		 pop	 edi
  000e8	5e		 pop	 esi
  000e9	5b		 pop	 ebx
  000ea	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2173 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 2174 : #if _HAS_CXX23
; 2175 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2176 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2177 :         _Count                  = _Allocated;
; 2178 :         return _Ptr;
; 2179 :     } else
; 2180 : #endif // _HAS_CXX23
; 2181 :     {
; 2182 :         return _Al.allocate(_Count);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	51		 push	 ecx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002b	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2183 :     }
; 2184 : }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 682  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 683  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 684  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 685  :         if (_STD is_constant_evaluated()) {
; 686  :             _Al.deallocate(_Ptr, _Count);
; 687  :         } else
; 688  : #endif // _HAS_CXX20
; 689  :         {
; 690  :             (void) _Al;
; 691  :             _STD _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00022	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	c1 e0 03	 shl	 eax, 3
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07@std@@YAXPAXI@Z ; std::_Deallocate<8>
  00032	83 c4 08	 add	 esp, 8

; 692  :         }
; 693  :     }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1495 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val2_0>$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	89 10		 mov	 DWORD PTR [eax], edx
  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\type_traits
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 1549 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __4C58012B_type_traits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 1550 :     return __builtin_addressof(_Val);

  00022	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1551 : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\utility
;	COMDAT ??$_Max_limit@H@std@@YAHXZ
_TEXT	SEGMENT
__Unsigned_max$1 = -8					; size = 4
??$_Max_limit@H@std@@YAHXZ PROC				; std::_Max_limit<int>, COMDAT

; 854  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __69285096_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 855  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 856  :     if constexpr (is_signed_v<_Ty>) {
; 857  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

  00026	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR __Unsigned_max$1[ebp], -1

; 858  :         return static_cast<_Ty>(_Unsigned_max >> 1);

  0002d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 859  :     } else {
; 860  :         return static_cast<_Ty>(-1);
; 861  :     }
; 862  : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Max_limit@H@std@@YAHXZ ENDP				; std::_Max_limit<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits>, COMDAT

; 194  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 195  :     // allocate _Bytes
; 196  :     if (_Bytes == 0) {

  00022	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00026	75 04		 jne	 SHORT $LN2@Allocate

; 197  :         return nullptr;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 23		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

  0002c	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00033	72 0e		 jb	 SHORT $LN3@Allocate

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00035	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0003e	83 c4 04	 add	 esp, 4
  00041	eb 0c		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);

  00043	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0004c	83 c4 04	 add	 esp, 4
$LN1@Allocate:

; 226  :     }
; 227  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
__Overflow_is_possible$ = -5				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0000f	b9 06 00 00 00	 mov	 ecx, 6
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00026	c6 45 fb 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0002a	c7 45 ec ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 84   :         if (_Count > _Max_possible) {

  00031	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00038	76 06		 jbe	 SHORT $LN2@Get_size_o

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

  0003a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0003f	90		 npad	 1
$LN2@Get_size_o:

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

  00040	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00043	c1 e0 03	 shl	 eax, 3
$LN1@Get_size_o:

; 90   : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\utility
;	COMDAT ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 762  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __69285096_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 763  :     // assign _New_val to _Val, return previous _Val
; 764  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d f8	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 765  :     _Val         = static_cast<_Other&&>(_New_val);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR __New_val$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 10		 mov	 DWORD PTR [eax], edx

; 766  :     return _Old_val;

  00038	8b 45 f8	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 767  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1549 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __4C58012B_type_traits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 1550 :     return __builtin_addressof(_Val);

  00022	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1551 : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 399  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __EC88E9B5_xutility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 400  : #if _HAS_CXX20
; 401  :     if (_STD is_constant_evaluated()) {
; 402  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 403  :     } else
; 404  : #endif // _HAS_CXX20
; 405  :     {
; 406  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0002f	83 c4 04	 add	 esp, 4
  00032	50		 push	 eax
  00033	6a 04		 push	 4
  00035	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0003a	83 c4 08	 add	 esp, 8
  0003d	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00049	8b 55 0c	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  0004c	8b 02		 mov	 eax, DWORD PTR [edx]
  0004e	89 01		 mov	 DWORD PTR [ecx], eax

; 407  :     }
; 408  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -8					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 804  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 805  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 806  :         ++_Capacity; // Take null terminator into consideration

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	83 c1 01	 add	 ecx, 1
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00031	89 0a		 mov	 DWORD PTR [edx], ecx

; 807  : 
; 808  :         pointer _Fancy_ptr = nullptr;

  00033	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Fancy_ptr$[ebp], 0

; 809  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 810  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00047	83 c4 08	 add	 esp, 8
  0004a	89 45 f8	 mov	 DWORD PTR __Fancy_ptr$[ebp], eax

; 811  :         } else {
; 812  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 813  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 814  :         }
; 815  : 
; 816  : #if _HAS_CXX20
; 817  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 818  :         // but likely more impactful to throughput.
; 819  :         if (_STD is_constant_evaluated()) {
; 820  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 821  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 822  :                 _STD construct_at(_Ptr + _Idx);
; 823  :             }
; 824  :         }
; 825  : #endif // _HAS_CXX20
; 826  :         --_Capacity;

  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	83 e9 01	 sub	 ecx, 1
  00055	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00058	89 0a		 mov	 DWORD PTR [edx], ecx

; 827  :         return _Fancy_ptr;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __Fancy_ptr$[ebp]

; 828  :     }

  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5b		 pop	 ebx
  00060	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00066	3b ec		 cmp	 ebp, esp
  00068	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 36   :     return _Ptr;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1099 : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00041	90		 npad	 1

; 1100 :     // deallocate a plain pointer using an allocator
; 1101 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1102 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1103 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00042	6a 01		 push	 1
  00044	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1104 :     } else {
; 1105 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1106 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1107 :     }
; 1108 : }

  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
  00076	cc		 int	 3
  00077	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
_TEXT	SEGMENT
tv391 = -280						; size = 8
tv283 = -272						; size = 8
tv318 = -272						; size = 8
tv135 = -268						; size = 4
tv284 = -268						; size = 4
$T2 = -260						; size = 4
__Ok$ = -56						; size = 8
__Pad$ = -40						; size = 4
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Data$ = 12						; size = 4
__Size$ = 16						; size = 4
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned int>, COMDAT

; 474  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d 7d a8	 lea	 edi, DWORD PTR [ebp-88]
  0001e	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  00046	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004b	90		 npad	 1

; 475  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 476  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 477  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

  0004c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 478  : 
; 479  :     _SizeT _Pad;
; 480  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  00053	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0005b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0005e	8b f4		 mov	 esi, esp
  00060	8b ca		 mov	 ecx, edx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00068	3b f4		 cmp	 esi, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv318[ebp], eax
  00075	89 95 f4 fe ff
	ff		 mov	 DWORD PTR tv318[ebp+4], edx
  0007b	83 bd f4 fe ff
	ff 00		 cmp	 DWORD PTR tv318[ebp+4], 0
  00082	7c 2c		 jl	 SHORT $LN10@Insert_str
  00084	7f 09		 jg	 SHORT $LN25@Insert_str
  00086	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR tv318[ebp], 0
  0008d	76 21		 jbe	 SHORT $LN10@Insert_str
$LN25@Insert_str:
  0008f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00097	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0009a	8b f4		 mov	 esi, esp
  0009c	8b ca		 mov	 ecx, edx
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	3b 45 10	 cmp	 eax, DWORD PTR __Size$[ebp]
  000ae	77 09		 ja	 SHORT $LN8@Insert_str
$LN10@Insert_str:

; 481  :         _Pad = 0;

  000b0	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Pad$[ebp], 0

; 482  :     } else {

  000b7	eb 22		 jmp	 SHORT $LN9@Insert_str
$LN8@Insert_str:

; 483  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  000b9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000be	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000c1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000c4	8b f4		 mov	 esi, esp
  000c6	8b ca		 mov	 ecx, edx
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	2b 45 10	 sub	 eax, DWORD PTR __Size$[ebp]
  000d8	89 45 d8	 mov	 DWORD PTR __Pad$[ebp], eax
$LN9@Insert_str:

; 484  :     }
; 485  : 
; 486  :     const typename _Ostr_t::sentry _Ok(_Ostr);

  000db	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000de	50		 push	 eax
  000df	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000e2	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 487  : 
; 488  :     if (!_Ok) {

  000ee	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000f1	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000f6	0f b6 c0	 movzx	 eax, al
  000f9	85 c0		 test	 eax, eax
  000fb	75 0e		 jne	 SHORT $LN11@Insert_str

; 489  :         _State |= _Ostr_t::badbit;

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00100	83 c8 04	 or	 eax, 4
  00103	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 490  :     } else { // state okay, insert characters

  00106	e9 29 02 00 00	 jmp	 $LN23@Insert_str
$LN11@Insert_str:

; 491  :         _TRY_IO_BEGIN

  0010b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 492  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  0010f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00112	8b 08		 mov	 ecx, DWORD PTR [eax]
  00114	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00117	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0011a	8b f4		 mov	 esi, esp
  0011c	8b ca		 mov	 ecx, edx
  0011e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00124	3b f4		 cmp	 esi, esp
  00126	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0012b	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00130	83 f8 40	 cmp	 eax, 64			; 00000040H
  00133	0f 84 8e 00 00
	00		 je	 $LN3@Insert_str

; 493  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00139	eb 09		 jmp	 SHORT $LN4@Insert_str
$LN2@Insert_str:
  0013b	8b 45 d8	 mov	 eax, DWORD PTR __Pad$[ebp]
  0013e	83 e8 01	 sub	 eax, 1
  00141	89 45 d8	 mov	 DWORD PTR __Pad$[ebp], eax
$LN4@Insert_str:
  00144	83 7d d8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00148	76 7d		 jbe	 SHORT $LN3@Insert_str

; 494  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0014a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0014d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014f	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00152	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00155	8b f4		 mov	 esi, esp
  00157	8b ca		 mov	 ecx, edx
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0015f	3b f4		 cmp	 esi, esp
  00161	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00166	8b f4		 mov	 esi, esp
  00168	0f b6 c0	 movzx	 eax, al
  0016b	50		 push	 eax
  0016c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0016f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00171	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00174	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00177	8b fc		 mov	 edi, esp
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0017f	3b fc		 cmp	 edi, esp
  00181	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00186	8b c8		 mov	 ecx, eax
  00188	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0018e	3b f4		 cmp	 esi, esp
  00190	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00195	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  0019b	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv135[ebp]
  001a1	50		 push	 eax
  001a2	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  001ad	83 c4 08	 add	 esp, 8
  001b0	0f b6 c8	 movzx	 ecx, al
  001b3	85 c9		 test	 ecx, ecx
  001b5	74 0b		 je	 SHORT $LN15@Insert_str

; 495  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  001b7	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  001ba	83 c8 04	 or	 eax, 4
  001bd	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 496  :                     break;

  001c0	eb 05		 jmp	 SHORT $LN3@Insert_str
$LN15@Insert_str:

; 497  :                 }
; 498  :             }

  001c2	e9 74 ff ff ff	 jmp	 $LN2@Insert_str
$LN3@Insert_str:

; 499  :         }
; 500  : 
; 501  :         if (_State == _Ostr_t::goodbit
; 502  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  001c7	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  001cb	75 7f		 jne	 SHORT $LN16@Insert_str
  001cd	8b 45 10	 mov	 eax, DWORD PTR __Size$[ebp]
  001d0	33 c9		 xor	 ecx, ecx
  001d2	8b f4		 mov	 esi, esp
  001d4	51		 push	 ecx
  001d5	50		 push	 eax
  001d6	8b 55 0c	 mov	 edx, DWORD PTR __Data$[ebp]
  001d9	52		 push	 edx
  001da	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  001df	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001e2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001e5	8b fc		 mov	 edi, esp
  001e7	8b ca		 mov	 ecx, edx
  001e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001ef	3b fc		 cmp	 edi, esp
  001f1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f6	8b c8		 mov	 ecx, eax
  001f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  001fe	3b f4		 cmp	 esi, esp
  00200	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00205	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv283[ebp], eax
  0020b	89 95 f4 fe ff
	ff		 mov	 DWORD PTR tv283[ebp+4], edx
  00211	8b 45 10	 mov	 eax, DWORD PTR __Size$[ebp]
  00214	33 c9		 xor	 ecx, ecx
  00216	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv391[ebp], eax
  0021c	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv391[ebp+4], ecx
  00222	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv283[ebp]
  00228	3b 95 e8 fe ff
	ff		 cmp	 edx, DWORD PTR tv391[ebp]
  0022e	75 0e		 jne	 SHORT $LN26@Insert_str
  00230	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv283[ebp+4]
  00236	3b 85 ec fe ff
	ff		 cmp	 eax, DWORD PTR tv391[ebp+4]
  0023c	74 0e		 je	 SHORT $LN16@Insert_str
$LN26@Insert_str:

; 503  :             _State |= _Ostr_t::badbit;

  0023e	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00241	83 c8 04	 or	 eax, 4
  00244	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 504  :         } else {

  00247	e9 8e 00 00 00	 jmp	 $LN6@Insert_str
$LN16@Insert_str:

; 505  :             for (; 0 < _Pad; --_Pad) { // pad on right

  0024c	eb 09		 jmp	 SHORT $LN7@Insert_str
$LN5@Insert_str:
  0024e	8b 45 d8	 mov	 eax, DWORD PTR __Pad$[ebp]
  00251	83 e8 01	 sub	 eax, 1
  00254	89 45 d8	 mov	 DWORD PTR __Pad$[ebp], eax
$LN7@Insert_str:
  00257	83 7d d8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  0025b	76 7d		 jbe	 SHORT $LN6@Insert_str

; 506  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0025d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00260	8b 08		 mov	 ecx, DWORD PTR [eax]
  00262	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00265	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00268	8b f4		 mov	 esi, esp
  0026a	8b ca		 mov	 ecx, edx
  0026c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00272	3b f4		 cmp	 esi, esp
  00274	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00279	8b f4		 mov	 esi, esp
  0027b	0f b6 c0	 movzx	 eax, al
  0027e	50		 push	 eax
  0027f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00282	8b 11		 mov	 edx, DWORD PTR [ecx]
  00284	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00287	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0028a	8b fc		 mov	 edi, esp
  0028c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00292	3b fc		 cmp	 edi, esp
  00294	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00299	8b c8		 mov	 ecx, eax
  0029b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  002a1	3b f4		 cmp	 esi, esp
  002a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002a8	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv284[ebp], eax
  002ae	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv284[ebp]
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  002c0	83 c4 08	 add	 esp, 8
  002c3	0f b6 c8	 movzx	 ecx, al
  002c6	85 c9		 test	 ecx, ecx
  002c8	74 0b		 je	 SHORT $LN18@Insert_str

; 507  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  002ca	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  002cd	83 c8 04	 or	 eax, 4
  002d0	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 508  :                     break;

  002d3	eb 05		 jmp	 SHORT $LN6@Insert_str
$LN18@Insert_str:

; 509  :                 }
; 510  :             }

  002d5	e9 74 ff ff ff	 jmp	 $LN5@Insert_str
$LN6@Insert_str:

; 511  :         }
; 512  : 
; 513  :         _Ostr.width(0);

  002da	8b f4		 mov	 esi, esp
  002dc	6a 00		 push	 0
  002de	6a 00		 push	 0
  002e0	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002e8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002eb	8b ca		 mov	 ecx, edx
  002ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  002f3	3b f4		 cmp	 esi, esp
  002f5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fa	90		 npad	 1
  002fb	eb 27		 jmp	 SHORT $LN20@Insert_str
__catch$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$0:

; 514  :         _CATCH_IO_(_Ostr_t, _Ostr)

  002fd	8b f4		 mov	 esi, esp
  002ff	6a 01		 push	 1
  00301	6a 04		 push	 4
  00303	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00306	8b 08		 mov	 ecx, DWORD PTR [eax]
  00308	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0030b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0030e	8b ca		 mov	 ecx, edx
  00310	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00316	3b f4		 cmp	 esi, esp
  00318	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0031d	90		 npad	 1
  0031e	b8 00 00 00 00	 mov	 eax, $LN24@Insert_str
  00323	c3		 ret	 0
$LN20@Insert_str:
  00324	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0032b	eb 07		 jmp	 SHORT $LN23@Insert_str
$LN24@Insert_str:
  0032d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN23@Insert_str:

; 515  :     }
; 516  : 
; 517  :     _Ostr.setstate(_State);

  00334	8b f4		 mov	 esi, esp
  00336	6a 00		 push	 0
  00338	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  0033b	50		 push	 eax
  0033c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0033f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00341	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00344	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0034d	3b f4		 cmp	 esi, esp
  0034f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00354	90		 npad	 1

; 518  :     return _Ostr;

  00355	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00358	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0035e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00365	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00368	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0036d	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 519  : }

  00373	52		 push	 edx
  00374	8b cd		 mov	 ecx, ebp
  00376	50		 push	 eax
  00377	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN30@Insert_str
  0037d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00382	58		 pop	 eax
  00383	5a		 pop	 edx
  00384	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00387	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0038e	59		 pop	 ecx
  0038f	5f		 pop	 edi
  00390	5e		 pop	 esi
  00391	5b		 pop	 ebx
  00392	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00395	33 cd		 xor	 ecx, ebp
  00397	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039c	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  003a2	3b ec		 cmp	 ebp, esp
  003a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003a9	8b e5		 mov	 esp, ebp
  003ab	5d		 pop	 ebp
  003ac	c3		 ret	 0
  003ad	0f 1f 00	 npad	 3
$LN30@Insert_str:
  003b0	01 00 00 00	 DD	 1
  003b4	00 00 00 00	 DD	 $LN29@Insert_str
$LN29@Insert_str:
  003b8	c8 ff ff ff	 DD	 -56			; ffffffc8H
  003bc	08 00 00 00	 DD	 8
  003c0	00 00 00 00	 DD	 $LN27@Insert_str
$LN27@Insert_str:
  003c4	5f		 DB	 95			; 0000005fH
  003c5	4f		 DB	 79			; 0000004fH
  003c6	6b		 DB	 107			; 0000006bH
  003c7	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a e4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-284]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 3355 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C634C807_memory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  0002e	50		 push	 eax
  0002f	0f b6 8d 2f ff
	ff ff		 movzx	 ecx, BYTE PTR $T1[ebp]
  00036	51		 push	 ecx
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
  0003f	90		 npad	 1
  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00023	50		 push	 eax
  00024	6a 00		 push	 0
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 _memset
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1502 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1503 :         return *this;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1504 :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
$T1 = -212						; size = 4
_this$ = -8						; size = 4
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 3440 :     _CONSTEXPR23 pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C634C807_memory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3441 :         return _STD exchange(_Mypair._Myval2, nullptr);

  0002b	c7 85 2c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  00035	8d 85 2c ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
  00045	83 c4 08	 add	 esp, 8

; 3442 :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 3410 :     _CONSTEXPR23 ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C634C807_memory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3411 :         if (_Mypair._Myval2) {

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00031	74 16		 je	 SHORT $LN2@unique_ptr

; 3412 :             _Mypair._Get_first()(_Mypair._Myval2);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	51		 push	 ecx
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
  00048	90		 npad	 1
$LN2@unique_ptr:

; 3413 :         }
; 3414 :     }

  00049	5f		 pop	 edi
  0004a	5e		 pop	 esi
  0004b	5b		 pop	 ebx
  0004c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
tv70 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 3300 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C634C807_memory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3301 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3302 :         delete _Ptr;

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002e	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00034	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR $T1[ebp], 0
  0003b	74 25		 je	 SHORT $LN3@operator
  0003d	8b f4		 mov	 esi, esp
  0003f	6a 01		 push	 1
  00041	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00047	8b 11		 mov	 edx, DWORD PTR [ecx]
  00049	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0004f	8b 02		 mov	 eax, DWORD PTR [edx]
  00051	ff d0		 call	 eax
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv70[ebp], eax
  00060	eb 0a		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00062	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv70[ebp], 0
$LN4@operator:

; 3303 :     }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Deallocate@$07@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07@std@@YAXPAXI@Z PROC			; std::_Deallocate<8>, COMDAT

; 230  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00041	90		 npad	 1

; 231  :     // deallocate storage allocated by _Allocate
; 232  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         ::operator delete(_Ptr);
; 235  :         return;
; 236  :     }
; 237  : #endif // _HAS_CXX20
; 238  : 
; 239  : #ifdef __cpp_aligned_new
; 240  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 241  :         size_t _Passed_align = _Align;
; 242  : #if defined(_M_IX86) || defined(_M_X64)
; 243  :         if (_Bytes >= _Big_allocation_threshold) {
; 244  :             // boost the alignment of big allocations to help autovectorization
; 245  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 246  :         }
; 247  : #endif // defined(_M_IX86) || defined(_M_X64)
; 248  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 249  :     } else
; 250  : #endif // defined(__cpp_aligned_new)
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) {

  00042	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00049	72 10		 jb	 SHORT $LN2@Deallocate

; 254  :             // boost the alignment of big allocations to help autovectorization
; 255  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0004e	50		 push	 eax
  0004f	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00058	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 256  :         }
; 257  : #endif // defined(_M_IX86) || defined(_M_X64)
; 258  :         ::operator delete(_Ptr, _Bytes);

  0005b	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0005e	50		 push	 eax
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00068	83 c4 08	 add	 esp, 8

; 259  :     }
; 260  : }

  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07@std@@YAXPAXI@Z ENDP			; std::_Deallocate<8>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 75   :         noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  0000f	b9 04 00 00 00	 mov	 ecx, 4
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __69285096_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00030	73 0b		 jae	 SHORT $LN3@max
  00032	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0003b	eb 09		 jmp	 SHORT $LN4@max
$LN3@max:
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00040	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  00046	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  0004c	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00052	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]

; 78   : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 289  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 36   :     return _Ptr;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z
_TEXT	SEGMENT
__Old_ptr$1 = -120					; size = 4
__Raw_new$ = -108					; size = 4
__New_ptr$ = -96					; size = 4
__Al$ = -84						; size = 4
__New_capacity$ = -72					; size = 4
__Old_capacity$ = -60					; size = 4
__New_size$ = -48					; size = 4
__Old_size$ = -36					; size = 4
__My_data$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>, COMDAT
; _this$ = ecx

; 2999 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d 84	 lea	 edi, DWORD PTR [ebp-124]
  00010	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00034	90		 npad	 1

; 3000 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3001 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3002 :         auto& _My_data            = _Mypair._Myval2;

  00035	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00038	89 45 e8	 mov	 DWORD PTR __My_data$[ebp], eax

; 3003 :         const size_type _Old_size = _My_data._Mysize;

  0003b	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00041	89 4d dc	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 3004 :         if (max_size() - _Old_size < _Size_increase) {

  00044	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0004c	2b 45 dc	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0004f	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00052	73 06		 jae	 SHORT $LN2@Reallocate

; 3005 :             _Xlen_string(); // result too long

  00054	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00059	90		 npad	 1
$LN2@Reallocate:

; 3006 :         }
; 3007 : 
; 3008 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005a	8b 45 dc	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0005d	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00060	89 45 d0	 mov	 DWORD PTR __New_size$[ebp], eax

; 3009 :         const size_type _Old_capacity = _My_data._Myres;

  00063	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00066	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00069	89 4d c4	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 3010 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0006c	8b 45 d0	 mov	 eax, DWORD PTR __New_size$[ebp]
  0006f	50		 push	 eax
  00070	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00078	89 45 b8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 3011 :         auto& _Al                     = _Getal();

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00083	89 45 ac	 mov	 DWORD PTR __Al$[ebp], eax

; 3012 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00086	8d 45 b8	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00089	50		 push	 eax
  0008a	8b 4d ac	 mov	 ecx, DWORD PTR __Al$[ebp]
  0008d	51		 push	 ecx
  0008e	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00093	83 c4 08	 add	 esp, 8
  00096	89 45 a0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 3013 : 
; 3014 :         _My_data._Orphan_all();

  00099	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
  000a1	90		 npad	 1

; 3015 :         _ASAN_STRING_REMOVE(*this);
; 3016 :         _My_data._Mysize      = _New_size;

  000a2	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a5	8b 4d d0	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000a8	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3017 :         _My_data._Myres       = _New_capacity;

  000ab	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ae	8b 4d b8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000b1	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 3018 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b4	8b 45 a0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000bd	83 c4 04	 add	 esp, 4
  000c0	89 45 94	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 3019 :         if (_Old_capacity > _Small_string_capacity) {

  000c3	83 7d c4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  000c7	76 4b		 jbe	 SHORT $LN3@Reallocate

; 3020 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c9	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	89 4d 88	 mov	 DWORD PTR __Old_ptr$1[ebp], ecx

; 3021 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000d2	0f b6 45 10	 movzx	 eax, BYTE PTR _<_Args_0>$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d dc	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000da	51		 push	 ecx
  000db	8b 55 88	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000e4	83 c4 04	 add	 esp, 4
  000e7	50		 push	 eax
  000e8	8b 45 94	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000eb	50		 push	 eax
  000ec	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000ef	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
  000f4	90		 npad	 1

; 3022 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000f5	8b 45 c4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d 88	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000fc	51		 push	 ecx
  000fd	8b 55 ac	 mov	 edx, DWORD PTR __Al$[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  00106	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3023 :             _My_data._Bx._Ptr = _New_ptr;

  00109	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0010c	8b 4d a0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0010f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3024 :         } else {

  00112	eb 30		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3025 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  00114	0f b6 45 10	 movzx	 eax, BYTE PTR _<_Args_0>$[ebp]
  00118	50		 push	 eax
  00119	8b 4d dc	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0011c	51		 push	 ecx
  0011d	8b 55 e8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00120	83 c2 04	 add	 edx, 4
  00123	52		 push	 edx
  00124	8b 45 94	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00127	50		 push	 eax
  00128	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  0012b	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
  00130	90		 npad	 1

; 3026 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00131	8d 45 a0	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00134	50		 push	 eax
  00135	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00138	83 c1 04	 add	 ecx, 4
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00141	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 3027 :         }
; 3028 : 
; 3029 :         _ASAN_STRING_CREATE(*this);
; 3030 :         return *this;

  00144	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3031 :     }

  00147	52		 push	 edx
  00148	8b cd		 mov	 ecx, ebp
  0014a	50		 push	 eax
  0014b	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@Reallocate
  00151	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00156	58		 pop	 eax
  00157	5a		 pop	 edx
  00158	5f		 pop	 edi
  00159	5e		 pop	 esi
  0015a	5b		 pop	 ebx
  0015b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015e	33 cd		 xor	 ecx, ebp
  00160	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00165	81 c4 3c 01 00
	00		 add	 esp, 316		; 0000013cH
  0016b	3b ec		 cmp	 ebp, esp
  0016d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00172	8b e5		 mov	 esp, ebp
  00174	5d		 pop	 ebp
  00175	c2 0c 00	 ret	 12			; 0000000cH
$LN9@Reallocate:
  00178	02 00 00 00	 DD	 2
  0017c	00 00 00 00	 DD	 $LN8@Reallocate
$LN8@Reallocate:
  00180	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00184	04 00 00 00	 DD	 4
  00188	00 00 00 00	 DD	 $LN6@Reallocate
  0018c	a0 ff ff ff	 DD	 -96			; ffffffa0H
  00190	04 00 00 00	 DD	 4
  00194	00 00 00 00	 DD	 $LN7@Reallocate
$LN7@Reallocate:
  00198	5f		 DB	 95			; 0000005fH
  00199	4e		 DB	 78			; 0000004eH
  0019a	65		 DB	 101			; 00000065H
  0019b	77		 DB	 119			; 00000077H
  0019c	5f		 DB	 95			; 0000005fH
  0019d	70		 DB	 112			; 00000070H
  0019e	74		 DB	 116			; 00000074H
  0019f	72		 DB	 114			; 00000072H
  001a0	00		 DB	 0
$LN6@Reallocate:
  001a1	5f		 DB	 95			; 0000005fH
  001a2	4e		 DB	 78			; 0000004eH
  001a3	65		 DB	 101			; 00000065H
  001a4	77		 DB	 119			; 00000077H
  001a5	5f		 DB	 95			; 0000005fH
  001a6	63		 DB	 99			; 00000063H
  001a7	61		 DB	 97			; 00000061H
  001a8	70		 DB	 112			; 00000070H
  001a9	61		 DB	 97			; 00000061H
  001aa	63		 DB	 99			; 00000063H
  001ab	69		 DB	 105			; 00000069H
  001ac	74		 DB	 116			; 00000074H
  001ad	79		 DB	 121			; 00000079H
  001ae	00		 DB	 0
??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator(), COMDAT
; _this$ = ecx

; 2290 :                 _STATIC_CALL_OPERATOR {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 2291 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00032	51		 push	 ecx
  00033	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2292 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  0003f	8d 45 14	 lea	 eax, DWORD PTR __Ch$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00046	03 4d 10	 add	 ecx, DWORD PTR __Old_size$[ebp]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0004f	83 c4 08	 add	 esp, 8

; 2293 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00052	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00059	8d 85 2f ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00063	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00066	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00070	83 c4 08	 add	 esp, 8

; 2294 :                 },

  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 10 00	 ret	 16			; 00000010H
??R<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@QBE@QADQBDID@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\type_traits
;	COMDAT ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >, COMDAT

; 1549 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __4C58012B_type_traits
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 1550 :     return __builtin_addressof(_Val);

  00022	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1551 : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1495 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00033	90		 npad	 1
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0003c	90		 npad	 1
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 942  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -224						; size = 4
__New_proxy$ = -20					; size = 4
_this$ = -8						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1183 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  00010	b9 09 00 00 00	 mov	 ecx, 9
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1184 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  0002b	6a 01		 push	 1
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00030	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 ec	 mov	 DWORD PTR __New_proxy$[ebp], eax

; 1185 :         _Construct_in_place(*_New_proxy, this);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  0004a	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00050	51		 push	 ecx
  00051	8b 55 ec	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  00054	52		 push	 edx
  00055	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  0005a	83 c4 08	 add	 esp, 8

; 1186 :         _Myproxy            = _New_proxy;

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d ec	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  00063	89 08		 mov	 DWORD PTR [eax], ecx

; 1187 :         _New_proxy->_Mycont = this;

  00065	8b 45 ec	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	89 08		 mov	 DWORD PTR [eax], ecx

; 1188 :     }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1111 : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 1112 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1113 :     using _Ty = typename _Alloc::value_type;
; 1114 :     _Ptr->~_Ty();
; 1115 :     _STD _Deallocate_plain(_Al, _Ptr);

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0002f	83 c4 08	 add	 esp, 8

; 1116 : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 952  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 953  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 954  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
  0003d	83 c4 04	 add	 esp, 4

; 955  :     }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -208						; size = 4
$T1 = -200						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 99   :         noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  0000f	b9 04 00 00 00	 mov	 ecx, 4
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __69285096_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 100  :     // return smaller of _Left and _Right
; 101  :     return _Right < _Left ? _Right : _Left;

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00030	73 0b		 jae	 SHORT $LN3@min
  00032	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00035	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0003b	eb 09		 jmp	 SHORT $LN4@min
$LN3@min:
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00040	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00046	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  0004c	89 95 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], edx
  00052	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]

; 102  : }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 128  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 129  :             return _Ok;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 130  :         }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -217						; size = 1
__Zero_uncaught_exceptions$ = -17			; size = 1
_this$ = -8						; size = 4
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 113  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 114  : #if !_HAS_EXCEPTIONS
; 115  :             const bool _Zero_uncaught_exceptions = true;
; 116  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  0002b	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	75 09		 jne	 SHORT $LN4@sentry
  00037	c6 85 27 ff ff
	ff 01		 mov	 BYTE PTR tv72[ebp], 1
  0003e	eb 07		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  00040	c6 85 27 ff ff
	ff 00		 mov	 BYTE PTR tv72[ebp], 0
$LN5@sentry:
  00047	8a 8d 27 ff ff
	ff		 mov	 cl, BYTE PTR tv72[ebp]
  0004d	88 4d ef	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 118  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 119  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 120  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 121  : 
; 122  :             if (_Zero_uncaught_exceptions) {

  00050	0f b6 45 ef	 movzx	 eax, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  00054	85 c0		 test	 eax, eax
  00056	74 15		 je	 SHORT $LN2@sentry

; 123  :                 this->_Myostr._Osfx();

  00058	8b f4		 mov	 esi, esp
  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00065	3b f4		 cmp	 esi, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	90		 npad	 1
$LN2@sentry:

; 124  :             }
; 125  :         }

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00075	90		 npad	 1
  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 96   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0001e	b9 06 00 00 00	 mov	 ecx, 6
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	90		 npad	 1
  0004a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 97   :             if (!_Ostr.good()) {

  0005d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00060	8b 08		 mov	 ecx, DWORD PTR [eax]
  00062	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00065	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00068	8b f4		 mov	 esi, esp
  0006a	8b ca		 mov	 ecx, edx
  0006c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00072	3b f4		 cmp	 esi, esp
  00074	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00079	0f b6 c0	 movzx	 eax, al
  0007c	85 c0		 test	 eax, eax
  0007e	75 09		 jne	 SHORT $LN2@sentry

; 98   :                 _Ok = false;

  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 99   :                 return;

  00087	eb 74		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 100  :             }
; 101  : 
; 102  :             const auto _Tied = _Ostr.tie();

  00089	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00091	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00094	8b f4		 mov	 esi, esp
  00096	8b ca		 mov	 ecx, edx
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0009e	3b f4		 cmp	 esi, esp
  000a0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a5	89 45 e0	 mov	 DWORD PTR __Tied$[ebp], eax

; 103  :             if (!_Tied || _Tied == _STD addressof(_Ostr)) {

  000a8	83 7d e0 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  000ac	74 11		 je	 SHORT $LN4@sentry
  000ae	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$addressof@V?$basic_ostream@DU?$char_traits@D@std@@@std@@@std@@YAPAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::addressof<std::basic_ostream<char,std::char_traits<char> > >
  000b7	83 c4 04	 add	 esp, 4
  000ba	39 45 e0	 cmp	 DWORD PTR __Tied$[ebp], eax
  000bd	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 104  :                 _Ok = true;

  000bf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 105  :                 return;

  000c6	eb 35		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 106  :             }
; 107  : 
; 108  :             _Tied->flush();

  000c8	8b f4		 mov	 esi, esp
  000ca	8b 4d e0	 mov	 ecx, DWORD PTR __Tied$[ebp]
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000d3	3b f4		 cmp	 esi, esp
  000d5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000da	90		 npad	 1

; 109  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000db	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000de	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e0	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000e3	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000e6	8b f4		 mov	 esi, esp
  000e8	8b ca		 mov	 ecx, edx
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000f0	3b f4		 cmp	 esi, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN1@sentry:

; 110  :         }

  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00104	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00111	59		 pop	 ecx
  00112	5f		 pop	 edi
  00113	5e		 pop	 esi
  00114	5b		 pop	 ebx
  00115	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0011b	3b ec		 cmp	 ebp, esp
  0011d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00122	8b e5		 mov	 esp, ebp
  00124	5d		 pop	 ebp
  00125	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	90		 npad	 1

; 83   :             const auto _Rdbuf = _Myostr.rdbuf();

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00055	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00063	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00066	8b f4		 mov	 esi, esp
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	89 45 e0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 84   :             if (_Rdbuf) {

  00078	83 7d e0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0007c	74 17		 je	 SHORT $LN2@Sentry_bas

; 85   :                 _Rdbuf->_Unlock();

  0007e	8b 45 e0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00081	8b 10		 mov	 edx, DWORD PTR [eax]
  00083	8b f4		 mov	 esi, esp
  00085	8b 4d e0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00088	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008b	ff d0		 call	 eax
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	90		 npad	 1
$LN2@Sentry_bas:

; 86   :             }
; 87   :         }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
  000b4	cc		 int	 3
  000b5	cc		 int	 3
  000b6	cc		 int	 3
  000b7	cc		 int	 3
  000b8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00031	89 08		 mov	 DWORD PTR [eax], ecx

; 76   :             const auto _Rdbuf = _Myostr.rdbuf();

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  0003e	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0004c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004f	8b f4		 mov	 esi, esp
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 77   :             if (_Rdbuf) {

  00061	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00065	74 17		 je	 SHORT $LN2@Sentry_bas

; 78   :                 _Rdbuf->_Lock();

  00067	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  0006a	8b 10		 mov	 edx, DWORD PTR [eax]
  0006c	8b f4		 mov	 esi, esp
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00071	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00074	ff d0		 call	 eax
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	90		 npad	 1
$LN2@Sentry_bas:

; 79   :             }
; 80   :         }

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00028	90		 npad	 1
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 100  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __D8902E06_istream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 101  :             return _Ok;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 102  :         }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 98   :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0001e	b9 03 00 00 00	 mov	 ecx, 3
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __D8902E06_istream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	90		 npad	 1
  0004a	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0004d	50		 push	 eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	8b f4		 mov	 esi, esp
  0005f	0f b6 45 0c	 movzx	 eax, BYTE PTR __Noskip$[ebp]
  00063	50		 push	 eax
  00064	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00079	88 42 04	 mov	 BYTE PTR [edx+4], al
  0007c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00083	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx
  00094	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 24 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-220]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 83   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __D8902E06_istream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	90		 npad	 1

; 84   :             const auto _Rdbuf = _Myistr.rdbuf();

  0004a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004f	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00055	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0005b	8b 02		 mov	 eax, DWORD PTR [edx]
  0005d	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00063	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00066	8b f4		 mov	 esi, esp
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0006e	3b f4		 cmp	 esi, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	89 45 e0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 85   :             if (_Rdbuf) {

  00078	83 7d e0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0007c	74 17		 je	 SHORT $LN2@Sentry_bas

; 86   :                 _Rdbuf->_Unlock();

  0007e	8b 45 e0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00081	8b 10		 mov	 edx, DWORD PTR [eax]
  00083	8b f4		 mov	 esi, esp
  00085	8b 4d e0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00088	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008b	ff d0		 call	 eax
  0008d	3b f4		 cmp	 esi, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	90		 npad	 1
$LN2@Sentry_bas:

; 87   :             }
; 88   :         }

  00095	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00098	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009f	59		 pop	 ecx
  000a0	5f		 pop	 edi
  000a1	5e		 pop	 esi
  000a2	5b		 pop	 ebx
  000a3	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a9	3b ec		 cmp	 ebp, esp
  000ab	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
  000b4	cc		 int	 3
  000b5	cc		 int	 3
  000b6	cc		 int	 3
  000b7	cc		 int	 3
  000b8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __D8902E06_istream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00031	89 08		 mov	 DWORD PTR [eax], ecx

; 77   :             const auto _Rdbuf = _Myistr.rdbuf();

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  0003e	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  00044	8b 02		 mov	 eax, DWORD PTR [edx]
  00046	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0004c	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004f	8b f4		 mov	 esi, esp
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 78   :             if (_Rdbuf) {

  00061	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00065	74 17		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Lock();

  00067	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  0006a	8b 10		 mov	 edx, DWORD PTR [eax]
  0006c	8b f4		 mov	 esi, esp
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00071	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00074	ff d0		 call	 eax
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	90		 npad	 1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	5f		 pop	 edi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx
  00084	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1018 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 1019 :     _Ostr.put(_Ostr.widen('\n'));

  00022	8b f4		 mov	 esi, esp
  00024	6a 0a		 push	 10			; 0000000aH
  00026	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0002e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00031	8b ca		 mov	 ecx, edx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00039	3b f4		 cmp	 esi, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b f4		 mov	 esi, esp
  00042	0f b6 c0	 movzx	 eax, al
  00045	50		 push	 eax
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  0004f	3b f4		 cmp	 esi, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	90		 npad	 1

; 1020 :     _Ostr.flush();

  00057	8b f4		 mov	 esi, esp
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00062	3b f4		 cmp	 esi, esp
  00064	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00069	90		 npad	 1

; 1021 :     return _Ostr;

  0006a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 1022 : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5b		 pop	 ebx
  00070	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00076	3b ec		 cmp	 ebp, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3420 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 3421 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00025	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0002a	50		 push	 eax
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0002e	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00033	50		 push	 eax
  00034	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@I@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@QBDI@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned int>
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3422 : }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv252 = -324						; size = 4
tv297 = -324						; size = 8
tv65 = -320						; size = 4
tv255 = -320						; size = 4
tv256 = -320						; size = 4
tv257 = -317						; size = 1
$T2 = -312						; size = 4
$T3 = -300						; size = 8
__Meta$4 = -92						; size = 4
__Size$5 = -80						; size = 4
__Ctype_fac$6 = -68					; size = 4
__Ok$ = -56						; size = 8
__Changed$ = -37					; size = 1
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3371 :     basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 34 01 00
	00		 sub	 esp, 308		; 00000134H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-132]
  00021	b9 1d 00 00 00	 mov	 ecx, 29			; 0000001dH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00049	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004e	90		 npad	 1

; 3372 :     using _Myis   = basic_istream<_Elem, _Traits>;
; 3373 :     using _Ctype  = typename _Myis::_Ctype;
; 3374 :     using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
; 3375 :     using _Mysizt = typename _Mystr::size_type;
; 3376 : 
; 3377 :     typename _Myis::iostate _State = _Myis::goodbit;

  0004f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 3378 :     bool _Changed                  = false;

  00056	c6 45 db 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 3379 :     const typename _Myis::sentry _Ok(_Istr);

  0005a	6a 00		 push	 0
  0005c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0005f	50		 push	 eax
  00060	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00063	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3380 : 
; 3381 :     if (_Ok) { // state okay, extract characters

  0006f	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00072	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  00077	0f b6 c0	 movzx	 eax, al
  0007a	85 c0		 test	 eax, eax
  0007c	0f 84 3f 02 00
	00		 je	 $LN19@operator

; 3382 :         const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());

  00082	8b f4		 mov	 esi, esp
  00084	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0008e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00090	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00093	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
  0009c	3b f4		 cmp	 esi, esp
  0009e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a3	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  000a9	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  000af	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv252[ebp], eax
  000b5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000b9	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv252[ebp]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000c5	83 c4 04	 add	 esp, 4
  000c8	89 45 bc	 mov	 DWORD PTR __Ctype_fac$6[ebp], eax
  000cb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  000cf	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000d5	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  000da	90		 npad	 1

; 3383 :         _Str.erase();

  000db	6a 00		 push	 0
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000e0	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  000e5	90		 npad	 1

; 3384 : 
; 3385 :         _TRY_IO_BEGIN

  000e6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 3386 :         _Mysizt _Size;
; 3387 :         if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {

  000ea	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ef	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000f2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000f5	8b f4		 mov	 esi, esp
  000f7	8b ca		 mov	 ecx, edx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000ff	3b f4		 cmp	 esi, esp
  00101	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00106	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv297[ebp], eax
  0010c	89 95 c0 fe ff
	ff		 mov	 DWORD PTR tv297[ebp+4], edx
  00112	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR tv297[ebp+4], 0
  00119	7c 56		 jl	 SHORT $LN7@operator
  0011b	7f 09		 jg	 SHORT $LN21@operator
  0011d	83 bd bc fe ff
	ff 00		 cmp	 DWORD PTR tv297[ebp], 0
  00124	76 4b		 jbe	 SHORT $LN7@operator
$LN21@operator:
  00126	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00129	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0012e	8b f0		 mov	 esi, eax
  00130	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00133	8b 08		 mov	 ecx, DWORD PTR [eax]
  00135	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00138	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0013b	8b fc		 mov	 edi, esp
  0013d	8b ca		 mov	 ecx, edx
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00145	3b fc		 cmp	 edi, esp
  00147	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014c	3b c6		 cmp	 eax, esi
  0014e	73 21		 jae	 SHORT $LN7@operator

; 3388 :             _Size = static_cast<_Mysizt>(_Istr.width());

  00150	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00153	8b 08		 mov	 ecx, DWORD PTR [eax]
  00155	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00158	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0015b	8b f4		 mov	 esi, esp
  0015d	8b ca		 mov	 ecx, edx
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  00165	3b f4		 cmp	 esi, esp
  00167	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016c	89 45 b0	 mov	 DWORD PTR __Size$5[ebp], eax

; 3389 :         } else {

  0016f	eb 0b		 jmp	 SHORT $LN8@operator
$LN7@operator:

; 3390 :             _Size = _Str.max_size();

  00171	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00174	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00179	89 45 b0	 mov	 DWORD PTR __Size$5[ebp], eax
$LN8@operator:

; 3391 :         }
; 3392 : 
; 3393 :         typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0017c	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0017f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00181	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00184	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00187	8b f4		 mov	 esi, esp
  00189	8b ca		 mov	 ecx, edx
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00191	3b f4		 cmp	 esi, esp
  00193	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00198	8b f4		 mov	 esi, esp
  0019a	8b c8		 mov	 ecx, eax
  0019c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  001a2	3b f4		 cmp	 esi, esp
  001a4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001a9	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv255[ebp], eax
  001af	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv255[ebp]
  001b5	89 45 a4	 mov	 DWORD PTR __Meta$4[ebp], eax

; 3394 : 
; 3395 :         for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {

  001b8	eb 43		 jmp	 SHORT $LN4@operator
$LN2@operator:
  001ba	8b 45 b0	 mov	 eax, DWORD PTR __Size$5[ebp]
  001bd	83 e8 01	 sub	 eax, 1
  001c0	89 45 b0	 mov	 DWORD PTR __Size$5[ebp], eax
  001c3	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001c6	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c8	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001cb	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ce	8b f4		 mov	 esi, esp
  001d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001d6	3b f4		 cmp	 esi, esp
  001d8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001dd	8b f4		 mov	 esi, esp
  001df	8b c8		 mov	 ecx, eax
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
  001e7	3b f4		 cmp	 esi, esp
  001e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ee	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv256[ebp], eax
  001f4	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv256[ebp]
  001fa	89 45 a4	 mov	 DWORD PTR __Meta$4[ebp], eax
$LN4@operator:
  001fd	83 7d b0 00	 cmp	 DWORD PTR __Size$5[ebp], 0
  00201	0f 86 81 00 00
	00		 jbe	 $LN3@operator

; 3396 :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  00207	8b 45 a4	 mov	 eax, DWORD PTR __Meta$4[ebp]
  0020a	50		 push	 eax
  0020b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00210	50		 push	 eax
  00211	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00216	83 c4 08	 add	 esp, 8
  00219	0f b6 c8	 movzx	 ecx, al
  0021c	85 c9		 test	 ecx, ecx
  0021e	74 0d		 je	 SHORT $LN9@operator

; 3397 :                 _State |= _Myis::eofbit;

  00220	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00223	83 c8 01	 or	 eax, 1
  00226	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 3398 :                 break;

  00229	eb 5d		 jmp	 SHORT $LN3@operator
  0022b	eb 56		 jmp	 SHORT $LN12@operator
$LN9@operator:

; 3399 :             } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  0022d	8b 45 a4	 mov	 eax, DWORD PTR __Meta$4[ebp]
  00230	50		 push	 eax
  00231	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00236	83 c4 04	 add	 esp, 4
  00239	8b f4		 mov	 esi, esp
  0023b	0f b6 c8	 movzx	 ecx, al
  0023e	51		 push	 ecx
  0023f	6a 48		 push	 72			; 00000048H
  00241	8b 4d bc	 mov	 ecx, DWORD PTR __Ctype_fac$6[ebp]
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?is@?$ctype@D@std@@QBE_NFD@Z
  0024a	3b f4		 cmp	 esi, esp
  0024c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00251	88 85 c3 fe ff
	ff		 mov	 BYTE PTR tv257[ebp], al
  00257	0f b6 95 c3 fe
	ff ff		 movzx	 edx, BYTE PTR tv257[ebp]
  0025e	85 d2		 test	 edx, edx
  00260	74 04		 je	 SHORT $LN11@operator

; 3400 :                 break; // whitespace, quit

  00262	eb 24		 jmp	 SHORT $LN3@operator

; 3401 :             } else { // add character to string

  00264	eb 1d		 jmp	 SHORT $LN12@operator
$LN11@operator:

; 3402 :                 _Str.push_back(_Traits::to_char_type(_Meta));

  00266	8b 45 a4	 mov	 eax, DWORD PTR __Meta$4[ebp]
  00269	50		 push	 eax
  0026a	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  0026f	83 c4 04	 add	 esp, 4
  00272	0f b6 c8	 movzx	 ecx, al
  00275	51		 push	 ecx
  00276	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00279	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
  0027e	90		 npad	 1

; 3403 :                 _Changed = true;

  0027f	c6 45 db 01	 mov	 BYTE PTR __Changed$[ebp], 1
$LN12@operator:

; 3404 :             }
; 3405 :         }

  00283	e9 32 ff ff ff	 jmp	 $LN2@operator
$LN3@operator:
  00288	eb 27		 jmp	 SHORT $LN15@operator
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 3406 :         _CATCH_IO_(_Myis, _Istr)

  0028a	8b f4		 mov	 esi, esp
  0028c	6a 01		 push	 1
  0028e	6a 04		 push	 4
  00290	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00293	8b 08		 mov	 ecx, DWORD PTR [eax]
  00295	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00298	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0029b	8b ca		 mov	 ecx, edx
  0029d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  002a3	3b f4		 cmp	 esi, esp
  002a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002aa	90		 npad	 1
  002ab	b8 00 00 00 00	 mov	 eax, $LN20@operator
  002b0	c3		 ret	 0
$LN15@operator:
  002b1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  002b8	eb 07		 jmp	 SHORT $LN19@operator
$LN20@operator:
  002ba	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN19@operator:

; 3407 :     }
; 3408 : 
; 3409 :     _Istr.width(0);

  002c1	8b f4		 mov	 esi, esp
  002c3	6a 00		 push	 0
  002c5	6a 00		 push	 0
  002c7	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  002ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  002cc	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  002cf	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d2	8b ca		 mov	 ecx, edx
  002d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  002da	3b f4		 cmp	 esi, esp
  002dc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e1	90		 npad	 1

; 3410 :     if (!_Changed) {

  002e2	0f b6 45 db	 movzx	 eax, BYTE PTR __Changed$[ebp]
  002e6	85 c0		 test	 eax, eax
  002e8	75 09		 jne	 SHORT $LN13@operator

; 3411 :         _State |= _Myis::failbit;

  002ea	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  002ed	83 c8 02	 or	 eax, 2
  002f0	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 3412 :     }
; 3413 : 
; 3414 :     _Istr.setstate(_State);

  002f3	8b f4		 mov	 esi, esp
  002f5	6a 00		 push	 0
  002f7	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  002fa	50		 push	 eax
  002fb	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  002fe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00300	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00303	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00306	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  0030c	3b f4		 cmp	 esi, esp
  0030e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00313	90		 npad	 1

; 3415 :     return _Istr;

  00314	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00317	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0031d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00324	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00327	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0032c	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 3416 : }

  00332	52		 push	 edx
  00333	8b cd		 mov	 ecx, ebp
  00335	50		 push	 eax
  00336	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN25@operator
  0033c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00341	58		 pop	 eax
  00342	5a		 pop	 edx
  00343	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00346	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0034d	59		 pop	 ecx
  0034e	5f		 pop	 edi
  0034f	5e		 pop	 esi
  00350	5b		 pop	 ebx
  00351	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00354	33 cd		 xor	 ecx, ebp
  00356	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035b	81 c4 44 01 00
	00		 add	 esp, 324		; 00000144H
  00361	3b ec		 cmp	 ebp, esp
  00363	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00368	8b e5		 mov	 esp, ebp
  0036a	5d		 pop	 ebp
  0036b	c3		 ret	 0
$LN25@operator:
  0036c	01 00 00 00	 DD	 1
  00370	00 00 00 00	 DD	 $LN24@operator
$LN24@operator:
  00374	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00378	08 00 00 00	 DD	 8
  0037c	00 00 00 00	 DD	 $LN22@operator
$LN22@operator:
  00380	5f		 DB	 95			; 0000005fH
  00381	4f		 DB	 79			; 0000004fH
  00382	6b		 DB	 107			; 0000006bH
  00383	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3:
  00008	8d 8d d4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 8a b8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-328]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -308						; size = 8
tv337 = -300						; size = 8
tv284 = -292						; size = 8
tv323 = -292						; size = 8
tv137 = -288						; size = 4
tv285 = -288						; size = 4
$T2 = -280						; size = 4
__Ok$ = -76						; size = 8
__Pad$ = -60						; size = 8
__Count$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 774  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d 7d 8c	 lea	 edi, DWORD PTR [ebp-116]
  0001e	b9 19 00 00 00	 mov	 ecx, 25			; 00000019H
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET __BB401B3C_ostream
  00046	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004b	90		 npad	 1

; 775  :     // insert NTBS into char stream
; 776  :     using _Elem = char;
; 777  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 778  : 
; 779  :     ios_base::iostate _State = ios_base::goodbit;

  0004c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 780  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00053	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0005c	83 c4 04	 add	 esp, 4
  0005f	33 c9		 xor	 ecx, ecx
  00061	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00064	89 4d d8	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 781  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00072	8b f4		 mov	 esi, esp
  00074	8b ca		 mov	 ecx, edx
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  00089	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv323[ebp+4], edx
  0008f	83 bd e0 fe ff
	ff 00		 cmp	 DWORD PTR tv323[ebp+4], 0
  00096	7c 79		 jl	 SHORT $LN17@operator
  00098	7f 09		 jg	 SHORT $LN24@operator
  0009a	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR tv323[ebp], 0
  000a1	76 6e		 jbe	 SHORT $LN17@operator
$LN24@operator:
  000a3	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a8	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000ab	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000ae	8b f4		 mov	 esi, esp
  000b0	8b ca		 mov	 ecx, edx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000b8	3b f4		 cmp	 esi, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv337[ebp], eax
  000c5	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv337[ebp+4], edx
  000cb	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv337[ebp+4]
  000d1	3b 45 d8	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  000d4	7c 3b		 jl	 SHORT $LN17@operator
  000d6	7f 0b		 jg	 SHORT $LN25@operator
  000d8	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv337[ebp]
  000de	3b 4d d4	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000e1	76 2e		 jbe	 SHORT $LN17@operator
$LN25@operator:
  000e3	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000e6	8b 02		 mov	 eax, DWORD PTR [edx]
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000eb	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000ee	8b f4		 mov	 esi, esp
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000f6	3b f4		 cmp	 esi, esp
  000f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fd	2b 45 d4	 sub	 eax, DWORD PTR __Count$[ebp]
  00100	1b 55 d8	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  00103	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  00109	89 95 d0 fe ff
	ff		 mov	 DWORD PTR tv135[ebp+4], edx
  0010f	eb 0b		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00111	0f 57 c0	 xorps	 xmm0, xmm0
  00114	66 0f 13 85 cc
	fe ff ff	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  0011c	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv135[ebp]
  00122	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv135[ebp+4]
  00128	89 4d c4	 mov	 DWORD PTR __Pad$[ebp], ecx
  0012b	89 55 c8	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 782  :     const typename _Myos::sentry _Ok(_Ostr);

  0012e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00131	50		 push	 eax
  00132	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00135	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  0013a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 783  : 
; 784  :     if (!_Ok) {

  00141	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00144	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00149	0f b6 c0	 movzx	 eax, al
  0014c	85 c0		 test	 eax, eax
  0014e	75 0e		 jne	 SHORT $LN8@operator

; 785  :         _State |= ios_base::badbit;

  00150	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00153	83 c8 04	 or	 eax, 4
  00156	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 786  :     } else { // state okay, insert

  00159	e9 42 02 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 787  :         _TRY_IO_BEGIN

  0015e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 788  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00162	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00165	8b 08		 mov	 ecx, DWORD PTR [eax]
  00167	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0016a	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0016d	8b f4		 mov	 esi, esp
  0016f	8b ca		 mov	 ecx, edx
  00171	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00177	3b f4		 cmp	 esi, esp
  00179	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017e	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00183	83 f8 40	 cmp	 eax, 64			; 00000040H
  00186	0f 84 a3 00 00
	00		 je	 $LN3@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0018c	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0018e	8b 45 c4	 mov	 eax, DWORD PTR __Pad$[ebp]
  00191	83 e8 01	 sub	 eax, 1
  00194	8b 4d c8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00197	83 d9 00	 sbb	 ecx, 0
  0019a	89 45 c4	 mov	 DWORD PTR __Pad$[ebp], eax
  0019d	89 4d c8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  001a0	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  001a4	0f 8c 85 00 00
	00		 jl	 $LN3@operator
  001aa	7f 06		 jg	 SHORT $LN26@operator
  001ac	83 7d c4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  001b0	76 7d		 jbe	 SHORT $LN3@operator
$LN26@operator:

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  001b2	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001b5	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b7	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001ba	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001bd	8b f4		 mov	 esi, esp
  001bf	8b ca		 mov	 ecx, edx
  001c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  001c7	3b f4		 cmp	 esi, esp
  001c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ce	8b f4		 mov	 esi, esp
  001d0	0f b6 c0	 movzx	 eax, al
  001d3	50		 push	 eax
  001d4	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001d7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001d9	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001dc	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001df	8b fc		 mov	 edi, esp
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001e7	3b fc		 cmp	 edi, esp
  001e9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ee	8b c8		 mov	 ecx, eax
  001f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001f6	3b f4		 cmp	 esi, esp
  001f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001fd	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  00203	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv137[ebp]
  00209	50		 push	 eax
  0020a	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0020f	50		 push	 eax
  00210	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00215	83 c4 08	 add	 esp, 8
  00218	0f b6 c8	 movzx	 ecx, al
  0021b	85 c9		 test	 ecx, ecx
  0021d	74 0b		 je	 SHORT $LN12@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

  0021f	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00222	83 c8 04	 or	 eax, 4
  00225	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 792  :                     break;

  00228	eb 05		 jmp	 SHORT $LN3@operator
$LN12@operator:

; 793  :                 }
; 794  :             }

  0022a	e9 5f ff ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 795  :         }
; 796  : 
; 797  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0022f	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  00233	75 64		 jne	 SHORT $LN13@operator
  00235	8b f4		 mov	 esi, esp
  00237	8b 45 d8	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0023a	50		 push	 eax
  0023b	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0023e	51		 push	 ecx
  0023f	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00242	52		 push	 edx
  00243	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00246	8b 08		 mov	 ecx, DWORD PTR [eax]
  00248	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0024b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0024e	8b fc		 mov	 edi, esp
  00250	8b ca		 mov	 ecx, edx
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00258	3b fc		 cmp	 edi, esp
  0025a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025f	8b c8		 mov	 ecx, eax
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  00267	3b f4		 cmp	 esi, esp
  00269	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0026e	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv284[ebp], eax
  00274	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv284[ebp+4], edx
  0027a	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv284[ebp]
  00280	3b 45 d4	 cmp	 eax, DWORD PTR __Count$[ebp]
  00283	75 0b		 jne	 SHORT $LN27@operator
  00285	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv284[ebp+4]
  0028b	3b 4d d8	 cmp	 ecx, DWORD PTR __Count$[ebp+4]
  0028e	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 798  :             _State |= ios_base::badbit;

  00290	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00293	83 c8 04	 or	 eax, 4
  00296	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 799  :         }
; 800  : 
; 801  :         if (_State == ios_base::goodbit) {

  00299	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  0029d	0f 85 a3 00 00
	00		 jne	 $LN6@operator

; 802  :             for (; 0 < _Pad; --_Pad) { // pad on right

  002a3	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002a5	8b 45 c4	 mov	 eax, DWORD PTR __Pad$[ebp]
  002a8	83 e8 01	 sub	 eax, 1
  002ab	8b 4d c8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  002ae	83 d9 00	 sbb	 ecx, 0
  002b1	89 45 c4	 mov	 DWORD PTR __Pad$[ebp], eax
  002b4	89 4d c8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  002b7	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  002bb	0f 8c 85 00 00
	00		 jl	 $LN6@operator
  002c1	7f 06		 jg	 SHORT $LN28@operator
  002c3	83 7d c4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002c7	76 7d		 jbe	 SHORT $LN6@operator
$LN28@operator:

; 803  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002c9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ce	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002d1	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002d4	8b f4		 mov	 esi, esp
  002d6	8b ca		 mov	 ecx, edx
  002d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  002de	3b f4		 cmp	 esi, esp
  002e0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002e5	8b f4		 mov	 esi, esp
  002e7	0f b6 c0	 movzx	 eax, al
  002ea	50		 push	 eax
  002eb	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002ee	8b 11		 mov	 edx, DWORD PTR [ecx]
  002f0	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002f6	8b fc		 mov	 edi, esp
  002f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002fe	3b fc		 cmp	 edi, esp
  00300	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00305	8b c8		 mov	 ecx, eax
  00307	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0030d	3b f4		 cmp	 esi, esp
  0030f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00314	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv285[ebp], eax
  0031a	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0032c	83 c4 08	 add	 esp, 8
  0032f	0f b6 c8	 movzx	 ecx, al
  00332	85 c9		 test	 ecx, ecx
  00334	74 0b		 je	 SHORT $LN15@operator

; 804  :                     _State |= ios_base::badbit; // insertion failed, quit

  00336	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00339	83 c8 04	 or	 eax, 4
  0033c	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 805  :                     break;

  0033f	eb 05		 jmp	 SHORT $LN6@operator
$LN15@operator:

; 806  :                 }
; 807  :             }

  00341	e9 5f ff ff ff	 jmp	 $LN5@operator
$LN6@operator:

; 808  :         }
; 809  : 
; 810  :         _Ostr.width(0);

  00346	8b f4		 mov	 esi, esp
  00348	6a 00		 push	 0
  0034a	6a 00		 push	 0
  0034c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0034f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00351	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00354	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00357	8b ca		 mov	 ecx, edx
  00359	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  0035f	3b f4		 cmp	 esi, esp
  00361	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00366	90		 npad	 1
  00367	eb 27		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 811  :         _CATCH_IO_(ios_base, _Ostr)

  00369	8b f4		 mov	 esi, esp
  0036b	6a 01		 push	 1
  0036d	6a 04		 push	 4
  0036f	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00372	8b 08		 mov	 ecx, DWORD PTR [eax]
  00374	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00377	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0037a	8b ca		 mov	 ecx, edx
  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00382	3b f4		 cmp	 esi, esp
  00384	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00389	90		 npad	 1
  0038a	b8 00 00 00 00	 mov	 eax, $LN23@operator
  0038f	c3		 ret	 0
$LN19@operator:
  00390	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00397	eb 07		 jmp	 SHORT $LN22@operator
$LN23@operator:
  00399	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN22@operator:

; 812  :     }
; 813  : 
; 814  :     _Ostr.setstate(_State);

  003a0	8b f4		 mov	 esi, esp
  003a2	6a 00		 push	 0
  003a4	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  003a7	50		 push	 eax
  003a8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  003ad	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003b0	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  003b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003b9	3b f4		 cmp	 esi, esp
  003bb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003c0	90		 npad	 1

; 815  :     return _Ostr;

  003c1	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003c4	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  003ca	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  003d1	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  003d4	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  003d9	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 816  : }

  003df	52		 push	 edx
  003e0	8b cd		 mov	 ecx, ebp
  003e2	50		 push	 eax
  003e3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@operator
  003e9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  003ee	58		 pop	 eax
  003ef	5a		 pop	 edx
  003f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003fa	59		 pop	 ecx
  003fb	5f		 pop	 edi
  003fc	5e		 pop	 esi
  003fd	5b		 pop	 ebx
  003fe	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00401	33 cd		 xor	 ecx, ebp
  00403	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00408	81 c4 34 01 00
	00		 add	 esp, 308		; 00000134H
  0040e	3b ec		 cmp	 ebp, esp
  00410	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00415	8b e5		 mov	 esp, ebp
  00417	5d		 pop	 ebp
  00418	c3		 ret	 0
  00419	0f 1f 00	 npad	 3
$LN32@operator:
  0041c	01 00 00 00	 DD	 1
  00420	00 00 00 00	 DD	 $LN31@operator
$LN31@operator:
  00424	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00428	08 00 00 00	 DD	 8
  0042c	00 00 00 00	 DD	 $LN29@operator
$LN29@operator:
  00430	5f		 DB	 95			; 0000005fH
  00431	4f		 DB	 79			; 0000004fH
  00432	6b		 DB	 107			; 0000006bH
  00433	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a c8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-312]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\gvent\OneDrive\Desktop\KPO\Lab1\Lab1\Lab1.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv279 = -540						; size = 4
tv281 = -540						; size = 4
tv283 = -540						; size = 4
tv67 = -536						; size = 4
tv285 = -536						; size = 4
tv286 = -536						; size = 4
$T2 = -528						; size = 4
$T3 = -516						; size = 28
$T4 = -480						; size = 4
$T5 = -468						; size = 28
$T6 = -432						; size = 28
$T7 = -396						; size = 4
_eventMonth$ = -192					; size = 4
_eventDay$ = -180					; size = 4
_eventDayNumber$ = -168					; size = 4
_daysUntil$ = -156					; size = 4
_birthdayMonth$ = -144					; size = 4
_birthdayDay$ = -132					; size = 4
_resultMonth$ = -120					; size = 4
_resultDay$ = -108					; size = 4
_dayNumber$ = -96					; size = 4
_year$ = -84						; size = 4
_month$ = -72						; size = 4
_day$ = -60						; size = 4
_dateString$ = -48					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 8    : int main() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd a4 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-348]
  00020	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __490706C5_Lab1@cpp
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004a	90		 npad	 1

; 9    :     setlocale(LC_ALL, "RUS");

  0004b	8b f4		 mov	 esi, esp
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_03EEFOAFAG@RUS@
  00052	6a 00		 push	 0
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  0005a	83 c4 08	 add	 esp, 8
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	90		 npad	 1

; 10   :     string dateString;

  00065	8d 4d d0	 lea	 ecx, DWORD PTR _dateString$[ebp]
  00068	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 11   :     int day, month, year;
; 12   : 
; 13   :     cout << "Введите дату в формате ДДММГГГГ: ";

  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@GJFPIFCJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?D?D?L?L?C?C?C?C@
  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00084	83 c4 08	 add	 esp, 8

; 14   :     cin >> dateString;

  00087	8d 45 d0	 lea	 eax, DWORD PTR _dateString$[ebp]
  0008a	50		 push	 eax
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
  00097	83 c4 08	 add	 esp, 8

; 15   :     if (!parseDate(dateString, day, month, year)) {

  0009a	8d 45 ac	 lea	 eax, DWORD PTR _year$[ebp]
  0009d	50		 push	 eax
  0009e	8d 4d b8	 lea	 ecx, DWORD PTR _month$[ebp]
  000a1	51		 push	 ecx
  000a2	8d 55 c4	 lea	 edx, DWORD PTR _day$[ebp]
  000a5	52		 push	 edx
  000a6	8d 45 d0	 lea	 eax, DWORD PTR _dateString$[ebp]
  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ?parseDate@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAH11@Z ; parseDate
  000af	83 c4 10	 add	 esp, 16			; 00000010H
  000b2	0f b6 c8	 movzx	 ecx, al
  000b5	85 c9		 test	 ecx, ecx
  000b7	75 37		 jne	 SHORT $LN4@main

; 16   :         cerr << "Ошибка: Неверный формат даты или недопустимая дата.\n";

  000b9	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@KJIHCF@?N?x?h?a?j?$OA?3?5?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?d?$OA?r?$PL?5?h?k@
  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c9	83 c4 08	 add	 esp, 8

; 17   :         return 1;

  000cc	c7 85 74 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T7[ebp], 1
  000d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 4d d0	 lea	 ecx, DWORD PTR _dateString$[ebp]
  000e0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e5	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  000eb	e9 71 04 00 00	 jmp	 $LN1@main
$LN4@main:

; 18   :     }
; 19   : 
; 20   :     cout << "Месяц: " <<getMonthName(month) << "\n";

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  000f5	8b 45 b8	 mov	 eax, DWORD PTR _month$[ebp]
  000f8	50		 push	 eax
  000f9	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000ff	51		 push	 ecx
  00100	e8 00 00 00 00	 call	 ?getMonthName@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; getMonthName
  00105	83 c4 08	 add	 esp, 8
  00108	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv67[ebp], eax
  0010e	8b 95 e8 fd ff
	ff		 mov	 edx, DWORD PTR tv67[ebp]
  00114	89 95 e4 fd ff
	ff		 mov	 DWORD PTR tv279[ebp], edx
  0011a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0011e	8b 85 e4 fd ff
	ff		 mov	 eax, DWORD PTR tv279[ebp]
  00124	50		 push	 eax
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_07ONJDPLPB@?L?e?q?$PP?v?3?5@
  0012a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00130	51		 push	 ecx
  00131	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00136	83 c4 08	 add	 esp, 8
  00139	50		 push	 eax
  0013a	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  0013f	83 c4 08	 add	 esp, 8
  00142	50		 push	 eax
  00143	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00148	83 c4 08	 add	 esp, 8
  0014b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0014f	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00155	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0015a	90		 npad	 1

; 21   : 
; 22   :     if (YearUtils::isLeapYear(year)) {

  0015b	8b 45 ac	 mov	 eax, DWORD PTR _year$[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ?isLeapYear@YearUtils@@YA_NH@Z ; YearUtils::isLeapYear
  00164	83 c4 04	 add	 esp, 4
  00167	0f b6 c8	 movzx	 ecx, al
  0016a	85 c9		 test	 ecx, ecx
  0016c	74 29		 je	 SHORT $LN5@main

; 23   :         cout << year << " год является високосным.\n";

  0016e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@DHNAMEDH@?5?c?n?d?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@
  00173	8b f4		 mov	 esi, esp
  00175	8b 45 ac	 mov	 eax, DWORD PTR _year$[ebp]
  00178	50		 push	 eax
  00179	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00185	3b f4		 cmp	 esi, esp
  00187	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00192	83 c4 08	 add	 esp, 8

; 24   :     }

  00195	eb 27		 jmp	 SHORT $LN6@main
$LN5@main:

; 25   :     else {
; 26   :         cout << year << " год не является високосным.\n";

  00197	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CADEGJDO@?5?c?n?d?5?m?e?5?$PP?b?k?$PP?e?r?q?$PP?5?b?h?q?n?j?n?q?m?$PL?l?4?6@
  0019c	8b f4		 mov	 esi, esp
  0019e	8b 45 ac	 mov	 eax, DWORD PTR _year$[ebp]
  001a1	50		 push	 eax
  001a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001ae	3b f4		 cmp	 esi, esp
  001b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001b5	50		 push	 eax
  001b6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001bb	83 c4 08	 add	 esp, 8
$LN6@main:

; 27   :     }
; 28   : 
; 29   :     int dayNumber = DateUtils::dayOfYear(day, month, year);

  001be	8b 45 ac	 mov	 eax, DWORD PTR _year$[ebp]
  001c1	50		 push	 eax
  001c2	8b 4d b8	 mov	 ecx, DWORD PTR _month$[ebp]
  001c5	51		 push	 ecx
  001c6	8b 55 c4	 mov	 edx, DWORD PTR _day$[ebp]
  001c9	52		 push	 edx
  001ca	e8 00 00 00 00	 call	 ?dayOfYear@DateUtils@@YAHHHH@Z ; DateUtils::dayOfYear
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH
  001d2	89 45 a0	 mov	 DWORD PTR _dayNumber$[ebp], eax

; 30   :     cout << "Порядковый номер дня в году: " << dayNumber << "\n";

  001d5	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  001da	8b f4		 mov	 esi, esp
  001dc	8b 45 a0	 mov	 eax, DWORD PTR _dayNumber$[ebp]
  001df	50		 push	 eax
  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@CMHEMFCG@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?b?5?c?n?d?s?3?5@
  001e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001eb	51		 push	 ecx
  001ec	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001f1	83 c4 08	 add	 esp, 8
  001f4	8b c8		 mov	 ecx, eax
  001f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  001fc	3b f4		 cmp	 esi, esp
  001fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00203	50		 push	 eax
  00204	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00209	83 c4 08	 add	 esp, 8

; 31   : 
; 32   :     int resultDay, resultMonth;
; 33   :    getDateFromDayNumber(dayNumber, year, resultDay, resultMonth);

  0020c	8d 45 88	 lea	 eax, DWORD PTR _resultMonth$[ebp]
  0020f	50		 push	 eax
  00210	8d 4d 94	 lea	 ecx, DWORD PTR _resultDay$[ebp]
  00213	51		 push	 ecx
  00214	8b 55 ac	 mov	 edx, DWORD PTR _year$[ebp]
  00217	52		 push	 edx
  00218	8b 45 a0	 mov	 eax, DWORD PTR _dayNumber$[ebp]
  0021b	50		 push	 eax
  0021c	e8 00 00 00 00	 call	 ?getDateFromDayNumber@@YAXHHAAH0@Z ; getDateFromDayNumber
  00221	83 c4 10	 add	 esp, 16			; 00000010H

; 34   :     cout << "Дата по порядковому номеру дня: " << resultDay << " " << getMonthName(month) << " " << year << "\n";

  00224	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00229	8b f4		 mov	 esi, esp
  0022b	8b 45 ac	 mov	 eax, DWORD PTR _year$[ebp]
  0022e	50		 push	 eax
  0022f	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00234	8b 4d b8	 mov	 ecx, DWORD PTR _month$[ebp]
  00237	51		 push	 ecx
  00238	8d 95 2c fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 ?getMonthName@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; getMonthName
  00244	83 c4 08	 add	 esp, 8
  00247	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv285[ebp], eax
  0024d	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  00253	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv281[ebp], eax
  00259	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0025d	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv281[ebp]
  00263	51		 push	 ecx
  00264	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00269	8b fc		 mov	 edi, esp
  0026b	8b 55 94	 mov	 edx, DWORD PTR _resultDay$[ebp]
  0026e	52		 push	 edx
  0026f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@JCCKEGFO@?D?$OA?r?$OA?5?o?n?5?o?n?p?$PP?d?j?n?b?n?l?s?5?m?n?l?e?p?s?5?d?m?$PP?3@
  00274	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00279	50		 push	 eax
  0027a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0027f	83 c4 08	 add	 esp, 8
  00282	8b c8		 mov	 ecx, eax
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0028a	3b fc		 cmp	 edi, esp
  0028c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00291	50		 push	 eax
  00292	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00297	83 c4 08	 add	 esp, 8
  0029a	50		 push	 eax
  0029b	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  002a0	83 c4 08	 add	 esp, 8
  002a3	50		 push	 eax
  002a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002a9	83 c4 08	 add	 esp, 8
  002ac	8b c8		 mov	 ecx, eax
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  002b4	3b f4		 cmp	 esi, esp
  002b6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002bb	50		 push	 eax
  002bc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002c1	83 c4 08	 add	 esp, 8
  002c4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002c8	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002ce	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002d3	90		 npad	 1

; 35   : 
; 36   :     cout << "Введите дату (ДД ММ): " << endl;

  002d4	8b f4		 mov	 esi, esp
  002d6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002db	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@MOBCIPFF@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?$CI?D?D?5?L?L?$CJ?3?5@
  002e0	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002e5	50		 push	 eax
  002e6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002eb	83 c4 08	 add	 esp, 8
  002ee	8b c8		 mov	 ecx, eax
  002f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002f6	3b f4		 cmp	 esi, esp
  002f8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002fd	90		 npad	 1
$LN2@main:

; 37   :     int birthdayDay, birthdayMonth;
; 38   :     while (!(cin >> birthdayDay >> birthdayMonth) || !isValidDate(birthdayDay, birthdayMonth)) {

  002fe	8b f4		 mov	 esi, esp
  00300	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _birthdayMonth$[ebp]
  00306	50		 push	 eax
  00307	8b fc		 mov	 edi, esp
  00309	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _birthdayDay$[ebp]
  0030f	51		 push	 ecx
  00310	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
  0031c	3b fc		 cmp	 edi, esp
  0031e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00323	8b c8		 mov	 ecx, eax
  00325	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
  0032b	3b f4		 cmp	 esi, esp
  0032d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00332	89 85 20 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  00338	8b 95 20 fe ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  0033e	8b 02		 mov	 eax, DWORD PTR [edx]
  00340	8b 8d 20 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  00346	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00349	8b f4		 mov	 esi, esp
  0034b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??7ios_base@std@@QBE_NXZ
  00351	3b f4		 cmp	 esi, esp
  00353	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00358	0f b6 c8	 movzx	 ecx, al
  0035b	85 c9		 test	 ecx, ecx
  0035d	75 1d		 jne	 SHORT $LN7@main
  0035f	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _birthdayMonth$[ebp]
  00365	50		 push	 eax
  00366	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _birthdayDay$[ebp]
  0036c	51		 push	 ecx
  0036d	e8 00 00 00 00	 call	 ?isValidDate@@YA_NHH@Z	; isValidDate
  00372	83 c4 08	 add	 esp, 8
  00375	0f b6 d0	 movzx	 edx, al
  00378	85 d2		 test	 edx, edx
  0037a	75 5d		 jne	 SHORT $LN3@main
$LN7@main:

; 39   :         cout << "Ошибка! Введите корректную дату (ДД ММ): ";

  0037c	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@EAGMMNGG@?N?x?h?a?j?$OA?$CB?5?B?b?e?d?h?r?e?5?j?n?p?p?e?j?r?m?s?$PO?5?d?$OA?r?s@
  00381	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00386	50		 push	 eax
  00387	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0038c	83 c4 08	 add	 esp, 8

; 40   :         cin.clear();

  0038f	8b f4		 mov	 esi, esp
  00391	6a 00		 push	 0
  00393	6a 00		 push	 0
  00395	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0039a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0039c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  003a2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003a5	8b ca		 mov	 ecx, edx
  003a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003ad	3b f4		 cmp	 esi, esp
  003af	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003b4	90		 npad	 1

; 41   :         cin.ignore(1000, '\n');

  003b5	8b f4		 mov	 esi, esp
  003b7	6a 0a		 push	 10			; 0000000aH
  003b9	6a 00		 push	 0
  003bb	68 e8 03 00 00	 push	 1000			; 000003e8H
  003c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  003c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?ignore@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@_JH@Z
  003cc	3b f4		 cmp	 esi, esp
  003ce	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003d3	90		 npad	 1

; 42   :     }

  003d4	e9 25 ff ff ff	 jmp	 $LN2@main
$LN3@main:

; 43   : 
; 44   :     int daysUntil = DateUtils::daysUntilBirthday(day, month, year, birthdayDay, birthdayMonth);

  003d9	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _birthdayMonth$[ebp]
  003df	50		 push	 eax
  003e0	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _birthdayDay$[ebp]
  003e6	51		 push	 ecx
  003e7	8b 55 ac	 mov	 edx, DWORD PTR _year$[ebp]
  003ea	52		 push	 edx
  003eb	8b 45 b8	 mov	 eax, DWORD PTR _month$[ebp]
  003ee	50		 push	 eax
  003ef	8b 4d c4	 mov	 ecx, DWORD PTR _day$[ebp]
  003f2	51		 push	 ecx
  003f3	e8 00 00 00 00	 call	 ?daysUntilBirthday@DateUtils@@YAHHHHHH@Z ; DateUtils::daysUntilBirthday
  003f8	83 c4 14	 add	 esp, 20			; 00000014H
  003fb	89 85 64 ff ff
	ff		 mov	 DWORD PTR _daysUntil$[ebp], eax

; 45   :     cout << "Дней до ближайшего дня рождения: " << daysUntil << "\n";

  00401	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00406	8b f4		 mov	 esi, esp
  00408	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _daysUntil$[ebp]
  0040e	50		 push	 eax
  0040f	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DHIPJDDH@?D?m?e?i?5?d?n?5?a?k?h?f?$OA?i?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP@
  00414	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0041a	51		 push	 ecx
  0041b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00420	83 c4 08	 add	 esp, 8
  00423	8b c8		 mov	 ecx, eax
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0042b	3b f4		 cmp	 esi, esp
  0042d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00432	50		 push	 eax
  00433	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00438	83 c4 08	 add	 esp, 8

; 46   : 
; 47   :     int eventDayNumber;
; 48   :     cout << "Введите порядковый номер дня года для события (например, 256 для Дня программиста): ";

  0043b	68 00 00 00 00	 push	 OFFSET ??_C@_0FF@BMJFHHK@?B?b?e?d?h?r?e?5?o?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?5?c?n@
  00440	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00445	50		 push	 eax
  00446	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0044b	83 c4 08	 add	 esp, 8

; 49   :     cin >> eventDayNumber;

  0044e	8b f4		 mov	 esi, esp
  00450	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _eventDayNumber$[ebp]
  00456	50		 push	 eax
  00457	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0045d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
  00463	3b f4		 cmp	 esi, esp
  00465	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0046a	90		 npad	 1

; 50   : 
; 51   :     int eventDay, eventMonth;
; 52   :     getEventDate(eventDayNumber, year, eventDay, eventMonth);

  0046b	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _eventMonth$[ebp]
  00471	50		 push	 eax
  00472	8d 8d 4c ff ff
	ff		 lea	 ecx, DWORD PTR _eventDay$[ebp]
  00478	51		 push	 ecx
  00479	8b 55 ac	 mov	 edx, DWORD PTR _year$[ebp]
  0047c	52		 push	 edx
  0047d	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _eventDayNumber$[ebp]
  00483	50		 push	 eax
  00484	e8 00 00 00 00	 call	 ?getEventDate@@YAXHHAAH0@Z ; getEventDate
  00489	83 c4 10	 add	 esp, 16			; 00000010H

; 53   :     cout << "Дата события: " << eventDay << " " << getMonthName(eventMonth) << " " << year << "\n";

  0048c	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00491	8b f4		 mov	 esi, esp
  00493	8b 45 ac	 mov	 eax, DWORD PTR _year$[ebp]
  00496	50		 push	 eax
  00497	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  0049c	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _eventMonth$[ebp]
  004a2	51		 push	 ecx
  004a3	8d 95 fc fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  004a9	52		 push	 edx
  004aa	e8 00 00 00 00	 call	 ?getMonthName@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; getMonthName
  004af	83 c4 08	 add	 esp, 8
  004b2	89 85 e8 fd ff
	ff		 mov	 DWORD PTR tv286[ebp], eax
  004b8	8b 85 e8 fd ff
	ff		 mov	 eax, DWORD PTR tv286[ebp]
  004be	89 85 e4 fd ff
	ff		 mov	 DWORD PTR tv283[ebp], eax
  004c4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  004c8	8b 8d e4 fd ff
	ff		 mov	 ecx, DWORD PTR tv283[ebp]
  004ce	51		 push	 ecx
  004cf	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  004d4	8b fc		 mov	 edi, esp
  004d6	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR _eventDay$[ebp]
  004dc	52		 push	 edx
  004dd	68 00 00 00 00	 push	 OFFSET ??_C@_0P@JLLDJCIK@?D?$OA?r?$OA?5?q?n?a?$PL?r?h?$PP?3?5@
  004e2	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004e7	50		 push	 eax
  004e8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004ed	83 c4 08	 add	 esp, 8
  004f0	8b c8		 mov	 ecx, eax
  004f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  004f8	3b fc		 cmp	 edi, esp
  004fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004ff	50		 push	 eax
  00500	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00505	83 c4 08	 add	 esp, 8
  00508	50		 push	 eax
  00509	e8 00 00 00 00	 call	 ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
  0050e	83 c4 08	 add	 esp, 8
  00511	50		 push	 eax
  00512	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00517	83 c4 08	 add	 esp, 8
  0051a	8b c8		 mov	 ecx, eax
  0051c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00522	3b f4		 cmp	 esi, esp
  00524	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00529	50		 push	 eax
  0052a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0052f	83 c4 08	 add	 esp, 8
  00532	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00536	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0053c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00541	90		 npad	 1

; 54   : 
; 55   : 
; 56   :     return 0;

  00542	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T2[ebp], 0
  0054c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00553	8d 4d d0	 lea	 ecx, DWORD PTR _dateString$[ebp]
  00556	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0055b	8b 85 f0 fd ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
$LN1@main:

; 57   : }

  00561	52		 push	 edx
  00562	8b cd		 mov	 ecx, ebp
  00564	50		 push	 eax
  00565	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@main
  0056b	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00570	58		 pop	 eax
  00571	5a		 pop	 edx
  00572	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00575	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0057c	59		 pop	 ecx
  0057d	5f		 pop	 edi
  0057e	5e		 pop	 esi
  0057f	5b		 pop	 ebx
  00580	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00583	33 cd		 xor	 ecx, ebp
  00585	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058a	81 c4 1c 02 00
	00		 add	 esp, 540		; 0000021cH
  00590	3b ec		 cmp	 ebp, esp
  00592	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00597	8b e5		 mov	 esp, ebp
  00599	5d		 pop	 ebp
  0059a	c3		 ret	 0
  0059b	90		 npad	 1
$LN26@main:
  0059c	0b 00 00 00	 DD	 11			; 0000000bH
  005a0	00 00 00 00	 DD	 $LN25@main
$LN25@main:
  005a4	d0 ff ff ff	 DD	 -48			; ffffffd0H
  005a8	1c 00 00 00	 DD	 28			; 0000001cH
  005ac	00 00 00 00	 DD	 $LN13@main
  005b0	c4 ff ff ff	 DD	 -60			; ffffffc4H
  005b4	04 00 00 00	 DD	 4
  005b8	00 00 00 00	 DD	 $LN14@main
  005bc	b8 ff ff ff	 DD	 -72			; ffffffb8H
  005c0	04 00 00 00	 DD	 4
  005c4	00 00 00 00	 DD	 $LN15@main
  005c8	ac ff ff ff	 DD	 -84			; ffffffacH
  005cc	04 00 00 00	 DD	 4
  005d0	00 00 00 00	 DD	 $LN16@main
  005d4	94 ff ff ff	 DD	 -108			; ffffff94H
  005d8	04 00 00 00	 DD	 4
  005dc	00 00 00 00	 DD	 $LN17@main
  005e0	88 ff ff ff	 DD	 -120			; ffffff88H
  005e4	04 00 00 00	 DD	 4
  005e8	00 00 00 00	 DD	 $LN18@main
  005ec	7c ff ff ff	 DD	 -132			; ffffff7cH
  005f0	04 00 00 00	 DD	 4
  005f4	00 00 00 00	 DD	 $LN19@main
  005f8	70 ff ff ff	 DD	 -144			; ffffff70H
  005fc	04 00 00 00	 DD	 4
  00600	00 00 00 00	 DD	 $LN20@main
  00604	58 ff ff ff	 DD	 -168			; ffffff58H
  00608	04 00 00 00	 DD	 4
  0060c	00 00 00 00	 DD	 $LN21@main
  00610	4c ff ff ff	 DD	 -180			; ffffff4cH
  00614	04 00 00 00	 DD	 4
  00618	00 00 00 00	 DD	 $LN22@main
  0061c	40 ff ff ff	 DD	 -192			; ffffff40H
  00620	04 00 00 00	 DD	 4
  00624	00 00 00 00	 DD	 $LN23@main
$LN23@main:
  00628	65		 DB	 101			; 00000065H
  00629	76		 DB	 118			; 00000076H
  0062a	65		 DB	 101			; 00000065H
  0062b	6e		 DB	 110			; 0000006eH
  0062c	74		 DB	 116			; 00000074H
  0062d	4d		 DB	 77			; 0000004dH
  0062e	6f		 DB	 111			; 0000006fH
  0062f	6e		 DB	 110			; 0000006eH
  00630	74		 DB	 116			; 00000074H
  00631	68		 DB	 104			; 00000068H
  00632	00		 DB	 0
$LN22@main:
  00633	65		 DB	 101			; 00000065H
  00634	76		 DB	 118			; 00000076H
  00635	65		 DB	 101			; 00000065H
  00636	6e		 DB	 110			; 0000006eH
  00637	74		 DB	 116			; 00000074H
  00638	44		 DB	 68			; 00000044H
  00639	61		 DB	 97			; 00000061H
  0063a	79		 DB	 121			; 00000079H
  0063b	00		 DB	 0
$LN21@main:
  0063c	65		 DB	 101			; 00000065H
  0063d	76		 DB	 118			; 00000076H
  0063e	65		 DB	 101			; 00000065H
  0063f	6e		 DB	 110			; 0000006eH
  00640	74		 DB	 116			; 00000074H
  00641	44		 DB	 68			; 00000044H
  00642	61		 DB	 97			; 00000061H
  00643	79		 DB	 121			; 00000079H
  00644	4e		 DB	 78			; 0000004eH
  00645	75		 DB	 117			; 00000075H
  00646	6d		 DB	 109			; 0000006dH
  00647	62		 DB	 98			; 00000062H
  00648	65		 DB	 101			; 00000065H
  00649	72		 DB	 114			; 00000072H
  0064a	00		 DB	 0
$LN20@main:
  0064b	62		 DB	 98			; 00000062H
  0064c	69		 DB	 105			; 00000069H
  0064d	72		 DB	 114			; 00000072H
  0064e	74		 DB	 116			; 00000074H
  0064f	68		 DB	 104			; 00000068H
  00650	64		 DB	 100			; 00000064H
  00651	61		 DB	 97			; 00000061H
  00652	79		 DB	 121			; 00000079H
  00653	4d		 DB	 77			; 0000004dH
  00654	6f		 DB	 111			; 0000006fH
  00655	6e		 DB	 110			; 0000006eH
  00656	74		 DB	 116			; 00000074H
  00657	68		 DB	 104			; 00000068H
  00658	00		 DB	 0
$LN19@main:
  00659	62		 DB	 98			; 00000062H
  0065a	69		 DB	 105			; 00000069H
  0065b	72		 DB	 114			; 00000072H
  0065c	74		 DB	 116			; 00000074H
  0065d	68		 DB	 104			; 00000068H
  0065e	64		 DB	 100			; 00000064H
  0065f	61		 DB	 97			; 00000061H
  00660	79		 DB	 121			; 00000079H
  00661	44		 DB	 68			; 00000044H
  00662	61		 DB	 97			; 00000061H
  00663	79		 DB	 121			; 00000079H
  00664	00		 DB	 0
$LN18@main:
  00665	72		 DB	 114			; 00000072H
  00666	65		 DB	 101			; 00000065H
  00667	73		 DB	 115			; 00000073H
  00668	75		 DB	 117			; 00000075H
  00669	6c		 DB	 108			; 0000006cH
  0066a	74		 DB	 116			; 00000074H
  0066b	4d		 DB	 77			; 0000004dH
  0066c	6f		 DB	 111			; 0000006fH
  0066d	6e		 DB	 110			; 0000006eH
  0066e	74		 DB	 116			; 00000074H
  0066f	68		 DB	 104			; 00000068H
  00670	00		 DB	 0
$LN17@main:
  00671	72		 DB	 114			; 00000072H
  00672	65		 DB	 101			; 00000065H
  00673	73		 DB	 115			; 00000073H
  00674	75		 DB	 117			; 00000075H
  00675	6c		 DB	 108			; 0000006cH
  00676	74		 DB	 116			; 00000074H
  00677	44		 DB	 68			; 00000044H
  00678	61		 DB	 97			; 00000061H
  00679	79		 DB	 121			; 00000079H
  0067a	00		 DB	 0
$LN16@main:
  0067b	79		 DB	 121			; 00000079H
  0067c	65		 DB	 101			; 00000065H
  0067d	61		 DB	 97			; 00000061H
  0067e	72		 DB	 114			; 00000072H
  0067f	00		 DB	 0
$LN15@main:
  00680	6d		 DB	 109			; 0000006dH
  00681	6f		 DB	 111			; 0000006fH
  00682	6e		 DB	 110			; 0000006eH
  00683	74		 DB	 116			; 00000074H
  00684	68		 DB	 104			; 00000068H
  00685	00		 DB	 0
$LN14@main:
  00686	64		 DB	 100			; 00000064H
  00687	61		 DB	 97			; 00000061H
  00688	79		 DB	 121			; 00000079H
  00689	00		 DB	 0
$LN13@main:
  0068a	64		 DB	 100			; 00000064H
  0068b	61		 DB	 97			; 00000061H
  0068c	74		 DB	 116			; 00000074H
  0068d	65		 DB	 101			; 00000065H
  0068e	53		 DB	 83			; 00000053H
  0068f	74		 DB	 116			; 00000074H
  00690	72		 DB	 114			; 00000072H
  00691	69		 DB	 105			; 00000069H
  00692	6e		 DB	 110			; 0000006eH
  00693	67		 DB	 103			; 00000067H
  00694	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _dateString$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$1:
  00008	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$2:
  00013	8d 8d 2c fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$3:
  0001e	8d 8d fc fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
__ehhandler$_main:
  0002e	90		 npad	 1
  0002f	90		 npad	 1
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 8a e0 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-544]
  0003d	33 c8		 xor	 ecx, eax
  0003f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00044	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  00053	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 44
_this$ = -8						; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 238  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00010	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __27C35076_xloctime
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 239  :         _Cvt = _Lobj._Getcvt();

  0002b	8b f4		 mov	 esi, esp
  0002d	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b 7d f8	 mov	 edi, DWORD PTR _this$[ebp]
  00047	83 c7 18	 add	 edi, 24			; 00000018H
  0004a	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0004f	8b f0		 mov	 esi, eax
  00051	f3 a5		 rep movsd

; 240  : 
; 241  :         if (is_same_v<_Elem2, wchar_t>) {

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	85 c0		 test	 eax, eax
  0005a	74 57		 je	 SHORT $LN2@Getvals

; 242  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0005c	8b f4		 mov	 esi, esp
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00074	83 c4 04	 add	 esp, 4
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 243  :             _Months =

  0007d	8b f4		 mov	 esi, esp
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 244  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 245  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  000a3	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  000a8	83 c4 04	 add	 esp, 4
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 246  :         } else {

  000b1	eb 70		 jmp	 SHORT $LN3@Getvals
$LN2@Getvals:

; 247  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 18	 add	 eax, 24			; 00000018H
  000b9	50		 push	 eax
  000ba	6a 00		 push	 0
  000bc	8b f4		 mov	 esi, esp
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 248  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	83 c0 18	 add	 eax, 24			; 00000018H
  000e3	50		 push	 eax
  000e4	6a 00		 push	 0
  000e6	8b f4		 mov	 esi, esp
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000f1	3b f4		 cmp	 esi, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 249  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00107	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	83 c0 18	 add	 eax, 24			; 00000018H
  0010d	50		 push	 eax
  0010e	6a 00		 push	 0
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  00115	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN3@Getvals:

; 250  :         }
; 251  :     }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  0012c	3b ec		 cmp	 ebp, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
$T1 = -252						; size = 44
_this$ = -8						; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 238  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 01 00
	00		 sub	 esp, 256		; 00000100H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d c0	 lea	 edi, DWORD PTR [ebp-64]
  00010	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __27C35076_xloctime
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 239  :         _Cvt = _Lobj._Getcvt();

  0002b	8b f4		 mov	 esi, esp
  0002d	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  0003d	3b f4		 cmp	 esi, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b 7d f8	 mov	 edi, DWORD PTR _this$[ebp]
  00047	83 c7 18	 add	 edi, 24			; 00000018H
  0004a	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  0004f	8b f0		 mov	 esi, eax
  00051	f3 a5		 rep movsd

; 240  : 
; 241  :         if (is_same_v<_Elem2, wchar_t>) {

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	85 c0		 test	 eax, eax
  0005a	74 57		 je	 SHORT $LN2@Getvals

; 242  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0005c	8b f4		 mov	 esi, esp
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00074	83 c4 04	 add	 esp, 4
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 243  :             _Months =

  0007d	8b f4		 mov	 esi, esp
  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  00095	83 c4 04	 add	 esp, 4
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 244  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 245  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  000a3	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  000a8	83 c4 04	 add	 esp, 4
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 246  :         } else {

  000b1	eb 70		 jmp	 SHORT $LN3@Getvals
$LN2@Getvals:

; 247  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  000b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 18	 add	 eax, 24			; 00000018H
  000b9	50		 push	 eax
  000ba	6a 00		 push	 0
  000bc	8b f4		 mov	 esi, esp
  000be	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  000c7	3b f4		 cmp	 esi, esp
  000c9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 248  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	83 c0 18	 add	 eax, 24			; 00000018H
  000e3	50		 push	 eax
  000e4	6a 00		 push	 0
  000e6	8b f4		 mov	 esi, esp
  000e8	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000f1	3b f4		 cmp	 esi, esp
  000f3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000fe	83 c4 0c	 add	 esp, 12			; 0000000cH
  00101	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 249  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00107	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	83 c0 18	 add	 eax, 24			; 00000018H
  0010d	50		 push	 eax
  0010e	6a 00		 push	 0
  00110	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  00115	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0011a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN3@Getvals:

; 250  :         }
; 251  :     }

  00123	5f		 pop	 edi
  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	81 c4 00 01 00
	00		 add	 esp, 256		; 00000100H
  0012c	3b ec		 cmp	 ebp, esp
  0012e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00133	8b e5		 mov	 esp, ebp
  00135	5d		 pop	 ebp
  00136	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptrnext$1 = -32					; size = 4
__Ptrdest$ = -20					; size = 4
__Count$ = -8						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 511  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0000f	b9 09 00 00 00	 mov	 ecx, 9
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __A850C1F8_xlocale
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 512  :     // convert C string to _Elem sequence using _Cvtvec
; 513  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _strlen
  0002f	83 c4 04	 add	 esp, 4
  00032	83 c0 01	 add	 eax, 1
  00035	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 514  : 
; 515  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00038	8b f4		 mov	 esi, esp
  0003a	68 03 02 00 00	 push	 515			; 00000203H
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@LEHJKL@C?3?2Program?5Files?2Microsoft?5Visu@
  00044	6a 02		 push	 2
  00046	6a 01		 push	 1
  00048	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0004b	50		 push	 eax
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00052	83 c4 14	 add	 esp, 20			; 00000014H
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	89 45 ec	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 516  : 
; 517  :     if (!_Ptrdest) {

  0005f	83 7d ec 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00063	75 06		 jne	 SHORT $LN5@Maklocstr

; 518  :         _Xbad_alloc();

  00065	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0006a	90		 npad	 1
$LN5@Maklocstr:

; 519  :     }
; 520  : 
; 521  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0006b	8b 45 ec	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  0006e	89 45 e0	 mov	 DWORD PTR __Ptrnext$1[ebp], eax
  00071	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00073	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00076	83 e8 01	 sub	 eax, 1
  00079	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0007c	8b 4d e0	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0007f	83 c1 01	 add	 ecx, 1
  00082	89 4d e0	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00085	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00088	83 c2 01	 add	 edx, 1
  0008b	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0008e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00092	76 0c		 jbe	 SHORT $LN3@Maklocstr

; 522  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00094	8b 45 e0	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0009c	88 10		 mov	 BYTE PTR [eax], dl

; 523  :     }

  0009e	eb d3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 524  : 
; 525  :     return _Ptrdest;

  000a0	8b 45 ec	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN1@Maklocstr:

; 526  : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  000ac	3b ec		 cmp	 ebp, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Ptrdest$ = -20					; size = 4
__Count$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 73   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  0000f	b9 06 00 00 00	 mov	 ecx, 6
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __36D7A7EF_xlocnum
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 74   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00026	8b f4		 mov	 esi, esp
  00028	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002b	50		 push	 eax
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  00032	83 c4 04	 add	 esp, 4
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	83 c0 01	 add	 eax, 1
  0003f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 75   : 
; 76   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00042	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Maklocwcs@std@@YAPA_WPB_W@Z@4JA
  00047	83 c0 03	 add	 eax, 3
  0004a	8b f4		 mov	 esi, esp
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@IDPJHLAK@C?3?2Program?5Files?2Microsoft?5Visu@
  00052	6a 02		 push	 2
  00054	6a 02		 push	 2
  00056	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00060	83 c4 14	 add	 esp, 20			; 00000014H
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	89 45 ec	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 77   : 
; 78   :     if (!_Ptrdest) {

  0006d	83 7d ec 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00071	75 06		 jne	 SHORT $LN2@Maklocwcs

; 79   :         _Xbad_alloc();

  00073	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00078	90		 npad	 1
$LN2@Maklocwcs:

; 80   :     }
; 81   : 
; 82   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00079	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0007c	50		 push	 eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00080	51		 push	 ecx
  00081	8b 55 ec	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  00084	52		 push	 edx
  00085	e8 00 00 00 00	 call	 _wmemcpy
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   :     return _Ptrdest;

  0008d	8b 45 ec	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN1@Maklocwcs:

; 84   : }

  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00099	3b ec		 cmp	 ebp, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -288						; size = 4
__Psave_guard$3 = -84					; size = 4
__Pfmod$4 = -72						; size = 4
__Pf$5 = -60						; size = 4
__Id$6 = -48						; size = 4
__Psave$7 = -36						; size = 4
__Lock$8 = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 420  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d 9c	 lea	 edi, DWORD PTR [ebp-100]
  0001d	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __A850C1F8_xlocale
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	90		 npad	 1

; 421  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00048	8b f4		 mov	 esi, esp
  0004a	6a 00		 push	 0
  0004c	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 422  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00068	89 45 dc	 mov	 DWORD PTR __Psave$7[ebp], eax

; 423  : 
; 424  :     const size_t _Id         = _Facet::id;

  0006b	8b f4		 mov	 esi, esp
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??Bid@locale@std@@QAEIXZ
  00079	3b f4		 cmp	 esi, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	89 45 d0	 mov	 DWORD PTR __Id$6[ebp], eax

; 425  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  00083	8b 45 d0	 mov	 eax, DWORD PTR __Id$6[ebp]
  00086	50		 push	 eax
  00087	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  0008f	89 45 c4	 mov	 DWORD PTR __Pf$5[ebp], eax

; 426  : 
; 427  :     if (!_Pf) {

  00092	83 7d c4 00	 cmp	 DWORD PTR __Pf$5[ebp], 0
  00096	0f 85 9f 00 00
	00		 jne	 $LN6@use_facet

; 428  :         if (_Psave) {

  0009c	83 7d dc 00	 cmp	 DWORD PTR __Psave$7[ebp], 0
  000a0	74 0b		 je	 SHORT $LN3@use_facet

; 429  :             _Pf = _Psave; // lazy facet already allocated

  000a2	8b 45 dc	 mov	 eax, DWORD PTR __Psave$7[ebp]
  000a5	89 45 c4	 mov	 DWORD PTR __Pf$5[ebp], eax
  000a8	e9 8e 00 00 00	 jmp	 $LN6@use_facet
$LN3@use_facet:

; 430  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  000ad	8b f4		 mov	 esi, esp
  000af	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  000b2	50		 push	 eax
  000b3	8d 4d dc	 lea	 ecx, DWORD PTR __Psave$7[ebp]
  000b6	51		 push	 ecx
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  000bd	83 c4 08	 add	 esp, 8
  000c0	3b f4		 cmp	 esi, esp
  000c2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	75 08		 jne	 SHORT $LN5@use_facet

; 431  : #if _HAS_EXCEPTIONS
; 432  :             _Throw_bad_cast(); // lazy disallowed

  000cc	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  000d1	90		 npad	 1

; 433  : #else
; 434  :             _CSTD abort(); // lazy disallowed
; 435  : #endif
; 436  :         } else { // queue up lazy facet for destruction

  000d2	eb 67		 jmp	 SHORT $LN6@use_facet
$LN5@use_facet:

; 437  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  000d4	8b 45 dc	 mov	 eax, DWORD PTR __Psave$7[ebp]
  000d7	89 45 b8	 mov	 DWORD PTR __Pfmod$4[ebp], eax

; 438  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  000da	6a 04		 push	 4
  000dc	8d 4d ac	 lea	 ecx, DWORD PTR __Psave_guard$3[ebp]
  000df	e8 00 00 00 00	 call	 ?__autoclassinit2@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEXI@Z
  000e4	8b 45 b8	 mov	 eax, DWORD PTR __Pfmod$4[ebp]
  000e7	50		 push	 eax
  000e8	8d 4d ac	 lea	 ecx, DWORD PTR __Psave_guard$3[ebp]
  000eb	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
  000f0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 439  : 
; 440  : #if defined(_M_CEE)
; 441  :             _Facet_Register_m(_Pfmod);
; 442  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 443  :             _Facet_Register(_Pfmod);

  000f4	8b 45 b8	 mov	 eax, DWORD PTR __Pfmod$4[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000fd	83 c4 04	 add	 esp, 4

; 444  : #endif // ^^^ !defined(_M_CEE) ^^^
; 445  : 
; 446  :             _Pfmod->_Incref();

  00100	8b 45 b8	 mov	 eax, DWORD PTR __Pfmod$4[ebp]
  00103	8b 10		 mov	 edx, DWORD PTR [eax]
  00105	8b f4		 mov	 esi, esp
  00107	8b 4d b8	 mov	 ecx, DWORD PTR __Pfmod$4[ebp]
  0010a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0010d	ff d0		 call	 eax
  0010f	3b f4		 cmp	 esi, esp
  00111	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00116	90		 npad	 1

; 447  :             _Facetptr<_Facet>::_Psave = _Psave;

  00117	8b 45 dc	 mov	 eax, DWORD PTR __Psave$7[ebp]
  0011a	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 448  :             _Pf                       = _Psave;

  0011f	8b 45 dc	 mov	 eax, DWORD PTR __Psave$7[ebp]
  00122	89 45 c4	 mov	 DWORD PTR __Pf$5[ebp], eax

; 449  : 
; 450  :             (void) _Psave_guard.release();

  00125	8d 4d ac	 lea	 ecx, DWORD PTR __Psave_guard$3[ebp]
  00128	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
  0012d	90		 npad	 1

; 451  :         }

  0012e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00132	8d 4d ac	 lea	 ecx, DWORD PTR __Psave_guard$3[ebp]
  00135	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0013a	90		 npad	 1
$LN6@use_facet:

; 452  :     }
; 453  : 
; 454  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  0013b	8b 45 c4	 mov	 eax, DWORD PTR __Pf$5[ebp]
  0013e	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00144	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0014b	8b f4		 mov	 esi, esp
  0014d	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00156	3b f4		 cmp	 esi, esp
  00158	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015d	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 455  :     _END_LOCK()
; 456  : } // end of use_facet body

  00163	52		 push	 edx
  00164	8b cd		 mov	 ecx, ebp
  00166	50		 push	 eax
  00167	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN15@use_facet
  0016d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00172	58		 pop	 eax
  00173	5a		 pop	 edx
  00174	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00177	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0017e	59		 pop	 ecx
  0017f	5f		 pop	 edi
  00180	5e		 pop	 esi
  00181	5b		 pop	 ebx
  00182	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00185	33 cd		 xor	 ecx, ebp
  00187	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018c	81 c4 24 01 00
	00		 add	 esp, 292		; 00000124H
  00192	3b ec		 cmp	 ebp, esp
  00194	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00199	8b e5		 mov	 esp, ebp
  0019b	5d		 pop	 ebp
  0019c	c3		 ret	 0
  0019d	0f 1f 00	 npad	 3
$LN15@use_facet:
  001a0	03 00 00 00	 DD	 3
  001a4	00 00 00 00	 DD	 $LN14@use_facet
$LN14@use_facet:
  001a8	e8 ff ff ff	 DD	 -24			; ffffffe8H
  001ac	04 00 00 00	 DD	 4
  001b0	00 00 00 00	 DD	 $LN10@use_facet
  001b4	dc ff ff ff	 DD	 -36			; ffffffdcH
  001b8	04 00 00 00	 DD	 4
  001bc	00 00 00 00	 DD	 $LN11@use_facet
  001c0	ac ff ff ff	 DD	 -84			; ffffffacH
  001c4	04 00 00 00	 DD	 4
  001c8	00 00 00 00	 DD	 $LN12@use_facet
$LN12@use_facet:
  001cc	5f		 DB	 95			; 0000005fH
  001cd	50		 DB	 80			; 00000050H
  001ce	73		 DB	 115			; 00000073H
  001cf	61		 DB	 97			; 00000061H
  001d0	76		 DB	 118			; 00000076H
  001d1	65		 DB	 101			; 00000065H
  001d2	5f		 DB	 95			; 0000005fH
  001d3	67		 DB	 103			; 00000067H
  001d4	75		 DB	 117			; 00000075H
  001d5	61		 DB	 97			; 00000061H
  001d6	72		 DB	 114			; 00000072H
  001d7	64		 DB	 100			; 00000064H
  001d8	00		 DB	 0
$LN11@use_facet:
  001d9	5f		 DB	 95			; 0000005fH
  001da	50		 DB	 80			; 00000050H
  001db	73		 DB	 115			; 00000073H
  001dc	61		 DB	 97			; 00000061H
  001dd	76		 DB	 118			; 00000076H
  001de	65		 DB	 101			; 00000065H
  001df	00		 DB	 0
$LN10@use_facet:
  001e0	5f		 DB	 95			; 0000005fH
  001e1	4c		 DB	 76			; 0000004cH
  001e2	6f		 DB	 111			; 0000006fH
  001e3	63		 DB	 99			; 00000063H
  001e4	6b		 DB	 107			; 0000006bH
  001e5	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$8[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
  00012	8d 4d ac	 lea	 ecx, DWORD PTR __Psave_guard$3[ebp]
  00015	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  0001f	90		 npad	 1
  00020	90		 npad	 1
  00021	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00025	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00028	8b 8a d8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-296]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00038	33 c8		 xor	 ecx, eax
  0003a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  00044	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -128						; size = 8
__Ptrnext$ = -112					; size = 4
__Ptrdest$ = -100					; size = 4
__Mbst1$ = -88						; size = 8
__Wc$ = -72						; size = 2
__Bytes$ = -60						; size = 4
__Ptr1$ = -48						; size = 4
__Wchars$ = -36						; size = 4
__Count1$ = -24						; size = 4
__Count$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 529  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 44 01 00
	00		 sub	 esp, 324		; 00000144H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 7c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-132]
  00012	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __A850C1F8_xlocale
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	90		 npad	 1

; 530  :     // convert C string to wchar_t sequence using _Cvtvec
; 531  :     size_t _Count;
; 532  :     size_t _Count1;
; 533  :     size_t _Wchars;
; 534  :     const char* _Ptr1;
; 535  :     int _Bytes;
; 536  :     wchar_t _Wc;
; 537  :     mbstate_t _Mbst1 = {};

  00033	33 c0		 xor	 eax, eax
  00035	89 45 a8	 mov	 DWORD PTR __Mbst1$[ebp], eax
  00038	89 45 ac	 mov	 DWORD PTR __Mbst1$[ebp+4], eax

; 538  : 
; 539  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  0003b	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _strlen
  00044	83 c4 04	 add	 esp, 4
  00047	83 c0 01	 add	 eax, 1
  0004a	89 45 e8	 mov	 DWORD PTR __Count1$[ebp], eax

; 540  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  0004d	8b 45 e8	 mov	 eax, DWORD PTR __Count1$[ebp]
  00050	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax
  00053	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  0005a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005d	89 4d d0	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  00060	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00062	8b 45 f4	 mov	 eax, DWORD PTR __Count$[ebp]
  00065	2b 45 c4	 sub	 eax, DWORD PTR __Bytes$[ebp]
  00068	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax
  0006b	8b 4d d0	 mov	 ecx, DWORD PTR __Ptr1$[ebp]
  0006e	03 4d c4	 add	 ecx, DWORD PTR __Bytes$[ebp]
  00071	89 4d d0	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  00074	8b 55 dc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  00077	83 c2 01	 add	 edx, 1
  0007a	89 55 dc	 mov	 DWORD PTR __Wchars$[ebp], edx
$LN4@Maklocstr:
  0007d	83 7d f4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00081	76 29		 jbe	 SHORT $LN3@Maklocstr

; 541  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  00083	8b 45 10	 mov	 eax, DWORD PTR __Cvt$[ebp]
  00086	50		 push	 eax
  00087	8d 4d a8	 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0008a	51		 push	 ecx
  0008b	8b 55 f4	 mov	 edx, DWORD PTR __Count$[ebp]
  0008e	52		 push	 edx
  0008f	8b 45 d0	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  00092	50		 push	 eax
  00093	8d 4d b8	 lea	 ecx, DWORD PTR __Wc$[ebp]
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 __Mbrtowc
  0009c	83 c4 14	 add	 esp, 20			; 00000014H
  0009f	89 45 c4	 mov	 DWORD PTR __Bytes$[ebp], eax
  000a2	83 7d c4 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  000a6	7f 02		 jg	 SHORT $LN8@Maklocstr

; 542  :             break;

  000a8	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 543  :         }
; 544  :     }

  000aa	eb b6		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 545  : 
; 546  :     ++_Wchars; // count terminating nul

  000ac	8b 45 dc	 mov	 eax, DWORD PTR __Wchars$[ebp]
  000af	83 c0 01	 add	 eax, 1
  000b2	89 45 dc	 mov	 DWORD PTR __Wchars$[ebp], eax

; 547  : 
; 548  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  000b5	8b f4		 mov	 esi, esp
  000b7	68 24 02 00 00	 push	 548			; 00000224H
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@LEHJKL@C?3?2Program?5Files?2Microsoft?5Visu@
  000c1	6a 02		 push	 2
  000c3	6a 02		 push	 2
  000c5	8b 45 dc	 mov	 eax, DWORD PTR __Wchars$[ebp]
  000c8	50		 push	 eax
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  000cf	83 c4 14	 add	 esp, 20			; 00000014H
  000d2	3b f4		 cmp	 esi, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	89 45 9c	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 549  : 
; 550  :     if (!_Ptrdest) {

  000dc	83 7d 9c 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  000e0	75 06		 jne	 SHORT $LN9@Maklocstr

; 551  :         _Xbad_alloc();

  000e2	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000e7	90		 npad	 1
$LN9@Maklocstr:

; 552  :     }
; 553  : 
; 554  :     wchar_t* _Ptrnext = _Ptrdest;

  000e8	8b 45 9c	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  000eb	89 45 90	 mov	 DWORD PTR __Ptrnext$[ebp], eax

; 555  :     mbstate_t _Mbst2  = {};

  000ee	33 c0		 xor	 eax, eax
  000f0	89 45 80	 mov	 DWORD PTR __Mbst2$[ebp], eax
  000f3	89 45 84	 mov	 DWORD PTR __Mbst2$[ebp+4], eax

; 556  : 
; 557  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  000f6	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  000f8	8b 45 f4	 mov	 eax, DWORD PTR __Count$[ebp]
  000fb	2b 45 c4	 sub	 eax, DWORD PTR __Bytes$[ebp]
  000fe	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax
  00101	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00104	03 4d c4	 add	 ecx, DWORD PTR __Bytes$[ebp]
  00107	89 4d 08	 mov	 DWORD PTR __Ptr$[ebp], ecx
  0010a	8b 55 dc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  0010d	83 ea 01	 sub	 edx, 1
  00110	89 55 dc	 mov	 DWORD PTR __Wchars$[ebp], edx
  00113	8b 45 90	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  00116	83 c0 02	 add	 eax, 2
  00119	89 45 90	 mov	 DWORD PTR __Ptrnext$[ebp], eax
$LN7@Maklocstr:
  0011c	83 7d dc 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  00120	76 29		 jbe	 SHORT $LN6@Maklocstr

; 558  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00122	8b 45 10	 mov	 eax, DWORD PTR __Cvt$[ebp]
  00125	50		 push	 eax
  00126	8d 4d 80	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  00129	51		 push	 ecx
  0012a	8b 55 e8	 mov	 edx, DWORD PTR __Count1$[ebp]
  0012d	52		 push	 edx
  0012e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00131	50		 push	 eax
  00132	8b 4d 90	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 __Mbrtowc
  0013b	83 c4 14	 add	 esp, 20			; 00000014H
  0013e	89 45 c4	 mov	 DWORD PTR __Bytes$[ebp], eax
  00141	83 7d c4 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00145	7f 02		 jg	 SHORT $LN10@Maklocstr

; 559  :             break;

  00147	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 560  :         }
; 561  :     }

  00149	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 562  : 
; 563  :     *_Ptrnext = L'\0';

  0014b	33 c0		 xor	 eax, eax
  0014d	8b 4d 90	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  00150	66 89 01	 mov	 WORD PTR [ecx], ax

; 564  : 
; 565  :     return _Ptrdest;

  00153	8b 45 9c	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN1@Maklocstr:

; 566  : }

  00156	52		 push	 edx
  00157	8b cd		 mov	 ecx, ebp
  00159	50		 push	 eax
  0015a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@Maklocstr
  00160	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00165	58		 pop	 eax
  00166	5a		 pop	 edx
  00167	5f		 pop	 edi
  00168	5e		 pop	 esi
  00169	5b		 pop	 ebx
  0016a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016d	33 cd		 xor	 ecx, ebp
  0016f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00174	81 c4 44 01 00
	00		 add	 esp, 324		; 00000144H
  0017a	3b ec		 cmp	 ebp, esp
  0017c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
  00185	0f 1f 00	 npad	 3
$LN16@Maklocstr:
  00188	03 00 00 00	 DD	 3
  0018c	00 00 00 00	 DD	 $LN15@Maklocstr
$LN15@Maklocstr:
  00190	b8 ff ff ff	 DD	 -72			; ffffffb8H
  00194	02 00 00 00	 DD	 2
  00198	00 00 00 00	 DD	 $LN12@Maklocstr
  0019c	a8 ff ff ff	 DD	 -88			; ffffffa8H
  001a0	08 00 00 00	 DD	 8
  001a4	00 00 00 00	 DD	 $LN13@Maklocstr
  001a8	80 ff ff ff	 DD	 -128			; ffffff80H
  001ac	08 00 00 00	 DD	 8
  001b0	00 00 00 00	 DD	 $LN14@Maklocstr
$LN14@Maklocstr:
  001b4	5f		 DB	 95			; 0000005fH
  001b5	4d		 DB	 77			; 0000004dH
  001b6	62		 DB	 98			; 00000062H
  001b7	73		 DB	 115			; 00000073H
  001b8	74		 DB	 116			; 00000074H
  001b9	32		 DB	 50			; 00000032H
  001ba	00		 DB	 0
$LN13@Maklocstr:
  001bb	5f		 DB	 95			; 0000005fH
  001bc	4d		 DB	 77			; 0000004dH
  001bd	62		 DB	 98			; 00000062H
  001be	73		 DB	 115			; 00000073H
  001bf	74		 DB	 116			; 00000074H
  001c0	31		 DB	 49			; 00000031H
  001c1	00		 DB	 0
$LN12@Maklocstr:
  001c2	5f		 DB	 95			; 0000005fH
  001c3	57		 DB	 87			; 00000057H
  001c4	63		 DB	 99			; 00000063H
  001c5	00		 DB	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
tv71 = -232						; size = 4
__Ptr0$ = -32						; size = 4
__Facptr$ = -20						; size = 4
_this$ = -8						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 362  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  00010	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __A850C1F8_xlocale
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 363  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00031	8b 55 08	 mov	 edx, DWORD PTR __Id$[ebp]
  00034	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00037	73 17		 jae	 SHORT $LN6@Getfacet
  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00042	8b 45 08	 mov	 eax, DWORD PTR __Id$[ebp]
  00045	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00048	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], ecx
  0004e	eb 0a		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  00050	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
  0005a	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv71[ebp]
  00060	89 55 ec	 mov	 DWORD PTR __Facptr$[ebp], edx

; 364  :         if (_Facptr || !_Ptr->_Xparent) {

  00063	83 7d ec 00	 cmp	 DWORD PTR __Facptr$[ebp], 0
  00067	75 0e		 jne	 SHORT $LN3@Getfacet
  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00073	85 d2		 test	 edx, edx
  00075	75 05		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 365  :             return _Facptr; // found facet or not transparent

  00077	8b 45 ec	 mov	 eax, DWORD PTR __Facptr$[ebp]
  0007a	eb 23		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 366  :         }
; 367  : 
; 368  :         // look in current locale
; 369  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  0007c	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00081	89 45 e0	 mov	 DWORD PTR __Ptr0$[ebp], eax

; 370  :         if (_Id < _Ptr0->_Facetcount) {

  00084	8b 45 e0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  00087	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0008a	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0008d	73 0e		 jae	 SHORT $LN4@Getfacet

; 371  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  0008f	8b 45 e0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  00092	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00095	8b 55 08	 mov	 edx, DWORD PTR __Id$[ebp]
  00098	8b 04 91	 mov	 eax, DWORD PTR [ecx+edx*4]
  0009b	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 372  :         }
; 373  : 
; 374  :         return nullptr; // no entry in current locale

  0009d	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 375  :     }

  0009f	5f		 pop	 edi
  000a0	5e		 pop	 esi
  000a1	5b		 pop	 ebx
  000a2	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a8	3b ec		 cmp	 ebp, esp
  000aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv84 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 339  :     ~locale() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __A850C1F8_xlocale
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 340  :         if (_Ptr) {

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 5a		 je	 SHORT $LN5@locale

; 341  :             delete _Ptr->_Decref();

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0003a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003f	8b f4		 mov	 esi, esp
  00041	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00044	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00047	ff d2		 call	 edx
  00049	3b f4		 cmp	 esi, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00056	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR $T1[ebp], 0
  0005d	74 25		 je	 SHORT $LN4@locale
  0005f	8b f4		 mov	 esi, esp
  00061	6a 01		 push	 1
  00063	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00071	8b 02		 mov	 eax, DWORD PTR [edx]
  00073	ff d0		 call	 eax
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  00082	eb 0a		 jmp	 SHORT $LN5@locale
$LN4@locale:
  00084	c7 85 24 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv84[ebp], 0
$LN5@locale:

; 342  :         }
; 343  :     }

  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00097	3b ec		 cmp	 ebp, esp
  00099	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d ec	 lea	 edi, DWORD PTR [ebp-20]
  0000f	b9 05 00 00 00	 mov	 ecx, 5
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __9C571AAC_typeinfo
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 63   :     _THROW(bad_cast{});

  00026	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  00031	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00036	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __CxxThrowException@8
  00042	90		 npad	 1
$LN1@Throw_bad_:

; 64   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_cast@std@@UAE@XZ
  00028	90		 npad	 1
  00029	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	74 0e		 je	 SHORT $LN2@scalar
  00031	6a 0c		 push	 12			; 0000000cH
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0002c	90		 npad	 1
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00028	90		 npad	 1
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 153  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8916352E_vcruntime_typeinfo@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 152  :         : exception("bad cast", 1)

  0002b	6a 01		 push	 1
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast@
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception
  0003a	90		 npad	 1

; 153  :     {

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 154  :     }

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00028	90		 npad	 1
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1506 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1507 :         return *this;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1508 :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1502 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1503 :         return *this;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1504 :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3085 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3086 :         return _Mypair._Get_first();

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3087 :     }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3081 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3082 :         return _Mypair._Get_first();

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3083 :     }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -233						; size = 1
__Al$2 = -32						; size = 4
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3055 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  00010	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3056 :         auto& _My_data = _Mypair._Myval2;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 3057 :         _My_data._Orphan_all();

  00031	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00034	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all
  00039	90		 npad	 1

; 3058 :         if (_My_data._Large_mode_engaged()) {

  0003a	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	74 31		 je	 SHORT $LN2@Tidy_deall

; 3059 :             _ASAN_STRING_REMOVE(*this);
; 3060 :             auto& _Al = _Getal();

  00049	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00051	89 45 e0	 mov	 DWORD PTR __Al$2[ebp], eax

; 3061 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

  00054	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00057	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0005a	51		 push	 ecx
  0005b	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  0005e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00061	50		 push	 eax
  00062	8b 4d e0	 mov	 ecx, DWORD PTR __Al$2[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3062 :             _My_data._Bx._Switch_to_buf();

  0006e	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00071	83 c1 04	 add	 ecx, 4
  00074	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
  00079	90		 npad	 1
$LN2@Tidy_deall:

; 3063 :         }
; 3064 : 
; 3065 :         _My_data._Mysize = 0;

  0007a	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 3066 :         _My_data._Myres  = _Small_string_capacity;

  00084	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00087	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 3067 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3068 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0008e	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00095	8d 85 17 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0009b	50		 push	 eax
  0009c	b9 01 00 00 00	 mov	 ecx, 1
  000a1	6b d1 00	 imul	 edx, ecx, 0
  000a4	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a7	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000b1	83 c4 08	 add	 esp, 8

; 3069 :     }

  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi
  000b6	5b		 pop	 ebx
  000b7	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  000bd	3b ec		 cmp	 ebp, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c4	8b e5		 mov	 esp, ebp
  000c6	5d		 pop	 ebp
  000c7	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
__New_size$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3049 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 3050 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3051 :         _Mypair._Myval2._Mysize = _New_size;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00031	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3052 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00034	c6 85 2f ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  0003b	8d 85 2f ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00041	50		 push	 eax
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0004a	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00053	83 c4 08	 add	 esp, 8

; 3053 :     }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  0005f	3b ec		 cmp	 ebp, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2965 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 2966 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00033	50		 push	 eax
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003a	51		 push	 ecx
  0003b	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2967 :     }

  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -216						; size = 4
__Masked$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2952 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  0000f	b9 07 00 00 00	 mov	 ecx, 7
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002f	90		 npad	 1

; 2953 :         const size_type _Masked = _Requested | _Alloc_mask;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00033	83 c8 0f	 or	 eax, 15			; 0000000fH
  00036	89 45 f4	 mov	 DWORD PTR __Masked$[ebp], eax

; 2954 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00039	8b 45 f4	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003c	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  0003f	76 05		 jbe	 SHORT $LN2@Calculate_

; 2955 :             return _Max;

  00041	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00044	eb 37		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2956 :         }
; 2957 : 
; 2958 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00046	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00049	d1 e8		 shr	 eax, 1
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  0004e	2b c8		 sub	 ecx, eax
  00050	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00053	76 05		 jbe	 SHORT $LN3@Calculate_

; 2959 :             return _Max;

  00055	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00058	eb 23		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2960 :         }
; 2961 : 
; 2962 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0005d	d1 e8		 shr	 eax, 1
  0005f	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00062	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00068	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0006e	51		 push	 ecx
  0006f	8d 55 f4	 lea	 edx, DWORD PTR __Masked$[ebp]
  00072	52		 push	 edx
  00073	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00078	83 c4 08	 add	 esp, 8
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Calculate_:

; 2963 :     }

  0007d	52		 push	 edx
  0007e	8b cd		 mov	 ecx, ebp
  00080	50		 push	 eax
  00081	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Calculate_
  00087	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008c	58		 pop	 eax
  0008d	5a		 pop	 edx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	5b		 pop	 ebx
  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  000a1	3b ec		 cmp	 ebp, esp
  000a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c3		 ret	 0
$LN8@Calculate_:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN7@Calculate_
$LN7@Calculate_:
  000b4	f4 ff ff ff	 DD	 -12			; fffffff4H
  000b8	04 00 00 00	 DD	 4
  000bc	00 00 00 00	 DD	 $LN6@Calculate_
$LN6@Calculate_:
  000c0	5f		 DB	 95			; 0000005fH
  000c1	4d		 DB	 77			; 0000004dH
  000c2	61		 DB	 97			; 00000061H
  000c3	73		 DB	 115			; 00000073H
  000c4	6b		 DB	 107			; 0000006bH
  000c5	65		 DB	 101			; 00000065H
  000c6	64		 DB	 100			; 00000064H
  000c7	00		 DB	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -264						; size = 4
$T2 = -252						; size = 4
$T3 = -240						; size = 4
__Storage_max$ = -36					; size = 4
__Alloc_max$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 2360 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  00010	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00034	90		 npad	 1

; 2361 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00043	83 c4 04	 add	 esp, 4
  00046	89 45 e8	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 2362 :         const size_type _Storage_max = // can always store small string

  00049	c7 85 10 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00053	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00059	50		 push	 eax
  0005a	8d 4d e8	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00063	83 c4 08	 add	 esp, 8
  00066	8b 10		 mov	 edx, DWORD PTR [eax]
  00068	89 55 dc	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 2363 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2364 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

  0006b	8b 45 dc	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0006e	83 e8 01	 sub	 eax, 1
  00071	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00077	e8 00 00 00 00	 call	 ??$_Max_limit@H@std@@YAHXZ ; std::_Max_limit<int>
  0007c	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00082	8d 8d 04 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00088	51		 push	 ecx
  00089	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00095	83 c4 08	 add	 esp, 8
  00098	8b 00		 mov	 eax, DWORD PTR [eax]

; 2365 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2366 :         );
; 2367 :     }

  0009a	52		 push	 edx
  0009b	8b cd		 mov	 ecx, ebp
  0009d	50		 push	 eax
  0009e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@max_size
  000a4	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000a9	58		 pop	 eax
  000aa	5a		 pop	 edx
  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	5b		 pop	 ebx
  000ae	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b1	33 cd		 xor	 ecx, ebp
  000b3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b8	81 c4 0c 01 00
	00		 add	 esp, 268		; 0000010cH
  000be	3b ec		 cmp	 ebp, esp
  000c0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	c3		 ret	 0
  000c9	0f 1f 00	 npad	 3
$LN6@max_size:
  000cc	01 00 00 00	 DD	 1
  000d0	00 00 00 00	 DD	 $LN5@max_size
$LN5@max_size:
  000d4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000d8	04 00 00 00	 DD	 4
  000dc	00 00 00 00	 DD	 $LN4@max_size
$LN4@max_size:
  000e0	5f		 DB	 95			; 0000005fH
  000e1	41		 DB	 65			; 00000041H
  000e2	6c		 DB	 108			; 0000006cH
  000e3	6c		 DB	 108			; 0000006cH
  000e4	6f		 DB	 111			; 0000006fH
  000e5	63		 DB	 99			; 00000063H
  000e6	5f		 DB	 95			; 0000005fH
  000e7	6d		 DB	 109			; 0000006dH
  000e8	61		 DB	 97			; 00000061H
  000e9	78		 DB	 120			; 00000078H
  000ea	00		 DB	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 2356 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 2357 :         return _Mypair._Myval2._Mysize;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 2358 :     }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 2342 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 2343 :         return _Mypair._Myval2._Myptr();

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2344 :     }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T1 = -245						; size = 1
$T2 = -233						; size = 1
__Ptr$3 = -32						; size = 4
__Old_size$ = -20					; size = 4
_this$ = -8						; size = 4
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 2276 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  00010	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 2277 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00031	89 4d ec	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 2278 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d ec	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0003a	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  0003d	73 4d		 jae	 SHORT $LN2@push_back

; 2279 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2280 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 2281 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00053	89 45 e0	 mov	 DWORD PTR __Ptr$3[ebp], eax

; 2282 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00056	8d 45 08	 lea	 eax, DWORD PTR __Ch$[ebp]
  00059	50		 push	 eax
  0005a	8b 4d e0	 mov	 ecx, DWORD PTR __Ptr$3[ebp]
  0005d	03 4d ec	 add	 ecx, DWORD PTR __Old_size$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00066	83 c4 08	 add	 esp, 8

; 2283 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00069	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
  00070	8d 85 17 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00076	50		 push	 eax
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0007a	8b 55 e0	 mov	 edx, DWORD PTR __Ptr$3[ebp]
  0007d	8d 44 0a 01	 lea	 eax, DWORD PTR [edx+ecx+1]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00087	83 c4 08	 add	 esp, 8

; 2284 :             return;

  0008a	eb 20		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 2285 :         }
; 2286 : 
; 2287 :         _Reallocate_grow_by(

  0008c	33 c0		 xor	 eax, eax
  0008e	88 85 0b ff ff
	ff		 mov	 BYTE PTR $T1[ebp], al
  00094	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00098	51		 push	 ecx
  00099	0f b6 95 0b ff
	ff ff		 movzx	 edx, BYTE PTR $T1[ebp]
  000a0	52		 push	 edx
  000a1	6a 01		 push	 1
  000a3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_1>@?1??push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??push_back@01@QAEXD@Z@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back'::`2'::<lambda_1>,char>
  000ab	90		 npad	 1
$LN1@push_back:

; 2288 :             1,
; 2289 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
; 2290 :                 _STATIC_CALL_OPERATOR {
; 2291 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2292 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);
; 2293 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 2294 :                 },
; 2295 :             _Ch);
; 2296 :     }

  000ac	5f		 pop	 edi
  000ad	5e		 pop	 esi
  000ae	5b		 pop	 ebx
  000af	81 c4 fc 00 00
	00		 add	 esp, 252		; 000000fcH
  000b5	3b ec		 cmp	 ebp, esp
  000b7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1856 :     _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1857 :         _Mypair._Myval2._Check_offset(_Off);

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002e	50		 push	 eax
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
  00037	90		 npad	 1

; 1858 :         _Eos(_Off);

  00038	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00044	90		 npad	 1

; 1859 :         return *this;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1860 :     }

  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5b		 pop	 ebx
  0004b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -48					; size = 4
_$S4$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1369 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00010	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00034	90		 npad	 1

; 1370 :         _Tidy_deallocate();

  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0003d	90		 npad	 1

; 1371 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1372 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00046	50		 push	 eax
  00047	8d 4d df	 lea	 ecx, DWORD PTR _$S4$[ebp]
  0004a	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0004f	8d 45 df	 lea	 eax, DWORD PTR _$S4$[ebp]
  00052	89 45 e8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1373 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00055	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005a	89 4d d0	 mov	 DWORD PTR __To_delete$[ebp], ecx

; 1374 :         _Mypair._Myval2._Myproxy = nullptr;

  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00060	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1375 :         _Delete_plain_internal(_Alproxy, _To_delete);

  00066	8b 45 d0	 mov	 eax, DWORD PTR __To_delete$[ebp]
  00069	50		 push	 eax
  0006a	8b 4d e8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  0006d	51		 push	 ecx
  0006e	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00073	83 c4 08	 add	 esp, 8

; 1376 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1377 :     }

  00076	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0007e	90		 npad	 1
  0007f	52		 push	 edx
  00080	8b cd		 mov	 ecx, ebp
  00082	50		 push	 eax
  00083	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@basic_stri
  00089	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008e	58		 pop	 eax
  0008f	5a		 pop	 edx
  00090	5f		 pop	 edi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx
  00093	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00096	33 cd		 xor	 ecx, ebp
  00098	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009d	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
  000ae	66 90		 npad	 2
$LN6@basic_stri:
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN5@basic_stri
$LN5@basic_stri:
  000b8	df ff ff ff	 DD	 -33			; ffffffdfH
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN4@basic_stri
$LN4@basic_stri:
  000c4	24		 DB	 36			; 00000024H
  000c5	53		 DB	 83			; 00000053H
  000c6	34		 DB	 52			; 00000034H
  000c7	00		 DB	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
__My_data$ = -20					; size = 4
_this$ = -8						; size = 4
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 836  :     _CONSTEXPR20 void _Construct_empty() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  00010	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 837  :         auto& _My_data = _Mypair._Myval2;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 838  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00039	50		 push	 eax
  0003a	8d 8d 23 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  00045	50		 push	 eax
  00046	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
  0004e	90		 npad	 1

; 839  : 
; 840  :         // initialize basic_string data members
; 841  :         _My_data._Mysize = 0;

  0004f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00052	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 842  :         _My_data._Myres  = _Small_string_capacity;

  00059	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0005c	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 843  :         _My_data._Activate_SSO_buffer();

  00063	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
  0006b	90		 npad	 1

; 844  : 
; 845  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 846  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0006c	c6 85 17 ff ff
	ff 00		 mov	 BYTE PTR $T1[ebp], 0
  00073	8d 85 17 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00079	50		 push	 eax
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	6b d1 00	 imul	 edx, ecx, 0
  00082	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00085	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0008f	83 c4 08	 add	 esp, 8

; 847  :     }

  00092	5f		 pop	 edi
  00093	5e		 pop	 esi
  00094	5b		 pop	 ebx
  00095	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  0009b	3b ec		 cmp	 ebp, esp
  0009d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 831  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00041	90		 npad	 1

; 832  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 833  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00042	8b 45 10	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	50		 push	 eax
  00049	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0004c	51		 push	 ecx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00050	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
  00055	90		 npad	 1

; 834  :     }

  00056	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00059	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00060	59		 pop	 ecx
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx
  00064	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0006a	3b ec		 cmp	 ebp, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
  00075	cc		 int	 3
  00076	cc		 int	 3
  00077	cc		 int	 3
  00078	cc		 int	 3
  00079	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 689  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0001e	b9 06 00 00 00	 mov	 ecx, 6
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	90		 npad	 1
  0004a	0f b6 85 23 ff
	ff ff		 movzx	 eax, BYTE PTR $T2[ebp]
  00051	50		 push	 eax
  00052	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  0005a	90		 npad	 1

; 690  :         _Construct_empty();

  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
  00063	90		 npad	 1

; 691  :     }

  00064	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
  00086	cc		 int	 3
  00087	cc		 int	 3
  00088	cc		 int	 3
  00089	cc		 int	 3
  0008a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 04	 add	 ecx, 4
  00026	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0002b	90		 npad	 1
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 482  :             _STD _Destroy_in_place(_Ptr);

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00034	83 c4 04	 add	 esp, 4

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	33 c0		 xor	 eax, eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	89 01		 mov	 DWORD PTR [ecx], eax
  00032	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00035	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00038	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi
  00040	5b		 pop	 ebx
  00041	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00047	3b ec		 cmp	 ebp, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 463  :         _Xout_of_range("invalid string position");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00027	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
  0002c	90		 npad	 1
$LN1@Xran:

; 464  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00031	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00034	73 06		 jae	 SHORT $LN2@Check_offs

; 451  :             _Xran();

  00036	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0003b	90		 npad	 1
$LN2@Check_offs:
$LN1@Check_offs:

; 452  :         }
; 453  :     }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  00010	b9 04 00 00 00	 mov	 ecx, 4
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 434  :         return _Myres > _Small_string_capacity;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 18 0f	 cmp	 DWORD PTR [eax+24], 15	; 0000000fH
  00032	76 0c		 jbe	 SHORT $LN3@Large_mode
  00034	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003e	eb 0a		 jmp	 SHORT $LN4@Large_mode
$LN3@Large_mode:
  00040	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
  0004a	0f b6 85 30 ff
	ff ff		 movzx	 eax, BYTE PTR tv66[ebp]

; 435  :     }

  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	5b		 pop	 ebx
  00054	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005a	3b ec		 cmp	 ebp, esp
  0005c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 425  :         const value_type* _Result = _Bx._Buf;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 04	 add	 eax, 4
  00031	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 426  :         if (_Large_mode_engaged()) {

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 12		 je	 SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 431  :     }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 416  :         value_type* _Result = _Bx._Buf;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 04	 add	 eax, 4
  00031	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 417  :         if (_Large_mode_engaged()) {

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0003c	0f b6 c0	 movzx	 eax, al
  0003f	85 c0		 test	 eax, eax
  00041	74 12		 je	 SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 422  :     }

  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx
  0005b	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00061	3b ec		 cmp	 ebp, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00033	90		 npad	 1
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 04	 add	 ecx, 4
  0003a	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
  0003f	90		 npad	 1

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00022	83 c8 ff	 or	 eax, -1

; 715  :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 952  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 953  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 954  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
  0003d	83 c4 04	 add	 esp, 4

; 955  :     }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 946  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
$LN4@deallocate:

; 947  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  0002b	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0002f	75 06		 jne	 SHORT $LN10@deallocate
  00031	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00035	75 02		 jne	 SHORT $LN8@deallocate
$LN10@deallocate:
  00037	eb 5d		 jmp	 SHORT $LN6@deallocate
$LN8@deallocate:
  00039	8b f4		 mov	 esi, esp
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00045	6a 00		 push	 0
  00047	68 b3 03 00 00	 push	 947			; 000003b3H
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@
  00051	6a 02		 push	 2
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00059	83 c4 18	 add	 esp, 24			; 00000018H
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	83 f8 01	 cmp	 eax, 1
  00066	75 01		 jne	 SHORT $LN12@deallocate
  00068	cc		 int	 3
$LN12@deallocate:
  00069	8b f4		 mov	 esi, esp
  0006b	6a 00		 push	 0
  0006d	68 b3 03 00 00	 push	 947			; 000003b3H
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00087	83 c4 14	 add	 esp, 20			; 00000014H
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	90		 npad	 1
  00092	33 c0		 xor	 eax, eax
  00094	75 a3		 jne	 SHORT $LN8@deallocate
$LN6@deallocate:
  00096	33 c0		 xor	 eax, eax
  00098	75 91		 jne	 SHORT $LN4@deallocate

; 948  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 949  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0009a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0009d	50		 push	 eax
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000a1	51		 push	 ecx
  000a2	e8 00 00 00 00	 call	 ??$_Deallocate@$07@std@@YAXPAXI@Z ; std::_Deallocate<8>
  000a7	83 c4 08	 add	 esp, 8

; 950  :     }

  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b3	3b ec		 cmp	 ebp, esp
  000b5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 938  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 516  : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __776EB5C9_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 517  :     _Xlength_error("string too long");

  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00027	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
  0002c	90		 npad	 1
$LN1@Xlen_strin:

; 518  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -200						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 399  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __EC88E9B5_xutility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 400  : #if _HAS_CXX20
; 401  :     if (_STD is_constant_evaluated()) {
; 402  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 403  :     } else
; 404  : #endif // _HAS_CXX20
; 405  :     {
; 406  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  0002f	83 c4 04	 add	 esp, 4
  00032	50		 push	 eax
  00033	6a 08		 push	 8
  00035	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0003a	83 c4 08	 add	 esp, 8
  0003d	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
  00043	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00046	8b 11		 mov	 edx, DWORD PTR [ecx]
  00048	52		 push	 edx
  00049	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0004f	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
  00054	90		 npad	 1

; 407  :     }
; 408  : }

  00055	5f		 pop	 edi
  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0005e	3b ec		 cmp	 ebp, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\utility
;	COMDAT ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 762  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __69285096_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 763  :     // assign _New_val to _Val, return previous _Val
; 764  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00026	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	89 4d f8	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 765  :     _Val         = static_cast<_Other&&>(_New_val);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR __New_val$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 10		 mov	 DWORD PTR [eax], edx

; 766  :     return _Old_val;

  00038	8b 45 f8	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 767  : }

  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx
  0003e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1205 :     void _Orphan_all_locked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00034	90		 npad	 1

; 1206 :         _Lockit _Lock(_LOCK_DEBUG);

  00035	8b f4		 mov	 esi, esp
  00037	6a 03		 push	 3
  00039	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00042	3b f4		 cmp	 esi, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	90		 npad	 1

; 1207 :         _Orphan_all_unlocked_v3();

  0004a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
  00052	90		 npad	 1

; 1208 :     }

  00053	8b f4		 mov	 esi, esp
  00055	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	90		 npad	 1
  00066	52		 push	 edx
  00067	8b cd		 mov	 ecx, ebp
  00069	50		 push	 eax
  0006a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Orphan_all
  00070	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00075	58		 pop	 eax
  00076	5a		 pop	 edx
  00077	5f		 pop	 edi
  00078	5e		 pop	 esi
  00079	5b		 pop	 ebx
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007d	33 cd		 xor	 ecx, ebp
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0008a	3b ec		 cmp	 ebp, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00091	8b e5		 mov	 esp, ebp
  00093	5d		 pop	 ebp
  00094	c3		 ret	 0
  00095	0f 1f 00	 npad	 3
$LN6@Orphan_all:
  00098	01 00 00 00	 DD	 1
  0009c	00 00 00 00	 DD	 $LN5@Orphan_all
$LN5@Orphan_all:
  000a0	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000a4	04 00 00 00	 DD	 4
  000a8	00 00 00 00	 DD	 $LN4@Orphan_all
$LN4@Orphan_all:
  000ac	5f		 DB	 95			; 0000005fH
  000ad	4c		 DB	 76			; 0000004cH
  000ae	6f		 DB	 111			; 0000006fH
  000af	63		 DB	 99			; 00000063H
  000b0	6b		 DB	 107			; 0000006bH
  000b1	00		 DB	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
__Pnext$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1345 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  00010	b9 09 00 00 00	 mov	 ecx, 9
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1346 :     if (!_Myproxy) { // no proxy, already done

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 38 00	 cmp	 DWORD PTR [eax], 0
  00031	75 02		 jne	 SHORT $LN5@Orphan_all

; 1347 :         return;

  00033	eb 41		 jmp	 SHORT $LN1@Orphan_all
$LN5@Orphan_all:

; 1348 :     }
; 1349 : 
; 1350 :     // proxy allocated, drain it
; 1351 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00035	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003f	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00045	50		 push	 eax
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004b	83 c2 04	 add	 edx, 4
  0004e	52		 push	 edx
  0004f	e8 00 00 00 00	 call	 ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00054	83 c4 08	 add	 esp, 8
  00057	89 45 ec	 mov	 DWORD PTR __Pnext$2[ebp], eax
  0005a	eb 09		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0005c	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	89 4d ec	 mov	 DWORD PTR __Pnext$2[ebp], ecx
$LN4@Orphan_all:
  00065	83 7d ec 00	 cmp	 DWORD PTR __Pnext$2[ebp], 0
  00069	74 0b		 je	 SHORT $LN3@Orphan_all

; 1352 :         _Pnext->_Myproxy = nullptr;

  0006b	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1353 :     }

  00074	eb e6		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:
$LN1@Orphan_all:

; 1354 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1356 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1357 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1358 : #if _HAS_CXX20
; 1359 :     if (_STD is_constant_evaluated()) {
; 1360 :         _Orphan_all_unlocked_v3();
; 1361 :     } else
; 1362 : #endif // _HAS_CXX20
; 1363 :     {
; 1364 :         _Orphan_all_locked_v3();

  0002b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
  00033	90		 npad	 1

; 1365 :     }
; 1366 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1367 : }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1174 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 1175 : 
; 1176 :     _Container_base12(const _Container_base12&)            = delete;
; 1177 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1178 : 
; 1179 :     _CONSTEXPR20 void _Orphan_all() noexcept;
; 1180 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1181 : 
; 1182 :     template <class _Alloc>
; 1183 :     _CONSTEXPR20 void _Alloc_proxy(_Alloc&& _Al) {
; 1184 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1185 :         _Construct_in_place(*_New_proxy, this);
; 1186 :         _Myproxy            = _New_proxy;
; 1187 :         _New_proxy->_Mycont = this;
; 1188 :     }
; 1189 : 
; 1190 :     template <class _Alloc>
; 1191 :     _CONSTEXPR20 void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1192 :         // pre: no iterators refer to the existing proxy
; 1193 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1194 :         _Construct_in_place(*_New_proxy, this);
; 1195 :         _New_proxy->_Mycont = this;
; 1196 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1197 :     }
; 1198 : 
; 1199 :     _Container_proxy* _Myproxy = nullptr;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1174 :     _CONSTEXPR20 _Container_base12() noexcept = default;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1166 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00031	89 08		 mov	 DWORD PTR [eax], ecx

; 1167 : 
; 1168 :     const _Container_base12* _Mycont       = nullptr;
; 1169 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 1166 :     _CONSTEXPR20 _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 169  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 170  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 171  :     _Bytes += _Non_user_size;

  00026	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002b	83 c1 27	 add	 ecx, 39			; 00000027H
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00031	89 0a		 mov	 DWORD PTR [edx], ecx

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00033	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	89 4d f8	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003b	b8 04 00 00 00	 mov	 eax, 4
  00040	6b c8 ff	 imul	 ecx, eax, -1
  00043	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00046	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00049	89 45 ec	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0004c	b8 04 00 00 00	 mov	 eax, 4
  00051	6b c8 fe	 imul	 ecx, eax, -2
  00054	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00057	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0005e	75 02		 jne	 SHORT $LN14@Adjust_man
  00060	eb 65		 jmp	 SHORT $LN6@Adjust_man
$LN14@Adjust_man:
  00062	8b f4		 mov	 esi, esp
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0006e	6a 00		 push	 0
  00070	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  00075	83 c0 09	 add	 eax, 9
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@
  0007e	6a 02		 push	 2
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00086	83 c4 18	 add	 esp, 24			; 00000018H
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	83 f8 01	 cmp	 eax, 1
  00093	75 01		 jne	 SHORT $LN19@Adjust_man
  00095	cc		 int	 3
$LN19@Adjust_man:
  00096	8b f4		 mov	 esi, esp
  00098	6a 00		 push	 0
  0009a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  0009f	83 c0 09	 add	 eax, 9
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b8	83 c4 14	 add	 esp, 20			; 00000014H
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	90		 npad	 1
  000c3	33 c0		 xor	 eax, eax
  000c5	75 9b		 jne	 SHORT $LN14@Adjust_man
$LN6@Adjust_man:
  000c7	33 c0		 xor	 eax, eax
  000c9	75 81		 jne	 SHORT $LN4@Adjust_man

; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000cb	c7 45 e0 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d7	2b 4d ec	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  000da	89 4d d4	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000dd	83 7d d4 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000e1	72 08		 jb	 SHORT $LN16@Adjust_man
  000e3	83 7d d4 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000e7	77 02		 ja	 SHORT $LN16@Adjust_man
  000e9	eb 65		 jmp	 SHORT $LN12@Adjust_man
$LN16@Adjust_man:
  000eb	8b f4		 mov	 esi, esp
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000f7	6a 00		 push	 0
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  000fe	83 c0 13	 add	 eax, 19			; 00000013H
  00101	50		 push	 eax
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@KIHIELAM@C?3?2Program?5Files?2Microsoft?5Visu@
  00107	6a 02		 push	 2
  00109	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0010f	83 c4 18	 add	 esp, 24			; 00000018H
  00112	3b f4		 cmp	 esi, esp
  00114	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00119	83 f8 01	 cmp	 eax, 1
  0011c	75 01		 jne	 SHORT $LN20@Adjust_man
  0011e	cc		 int	 3
$LN20@Adjust_man:
  0011f	8b f4		 mov	 esi, esp
  00121	6a 00		 push	 0
  00123	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  00128	83 c0 13	 add	 eax, 19			; 00000013H
  0012b	50		 push	 eax
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@NMPKGKJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00136	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  0013b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00141	83 c4 14	 add	 esp, 20			; 00000014H
  00144	3b f4		 cmp	 esi, esp
  00146	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014b	90		 npad	 1
  0014c	33 c0		 xor	 eax, eax
  0014e	75 9b		 jne	 SHORT $LN16@Adjust_man
$LN12@Adjust_man:
  00150	33 c0		 xor	 eax, eax
  00152	75 89		 jne	 SHORT $LN10@Adjust_man

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00154	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00157	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0015a	89 08		 mov	 DWORD PTR [eax], ecx

; 190  : }

  0015c	5f		 pop	 edi
  0015d	5e		 pop	 esi
  0015e	5b		 pop	 ebx
  0015f	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00165	3b ec		 cmp	 ebp, esp
  00167	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 100  :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 101  :         return ::operator new(_Bytes);

  00022	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002b	83 c4 04	 add	 esp, 4

; 102  :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -208						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 74   : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d ec	 lea	 edi, DWORD PTR [ebp-20]
  0000f	b9 05 00 00 00	 mov	 ecx, 5
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __03BD3355_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 75   :     _THROW(bad_array_new_length{});

  00026	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  00031	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00036	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __CxxThrowException@8
  00042	90		 npad	 1
$LN1@Throw_bad_:

; 76   : }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 456  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 457  :         return static_cast<int_type>(EOF);

  00022	83 c8 ff	 or	 eax, -1

; 458  :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 448  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d fc	 lea	 edi, DWORD PTR [ebp-4]
  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00025	90		 npad	 1

; 449  :         return _Left == _Right;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00029	3b 45 0c	 cmp	 eax, DWORD PTR __Right$[ebp]
  0002c	75 0c		 jne	 SHORT $LN3@eq_int_typ
  0002e	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  00038	eb 0a		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  0003a	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  00044	0f b6 85 3c ff
	ff ff		 movzx	 eax, BYTE PTR tv65[ebp]

; 450  :     }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00054	3b ec		 cmp	 ebp, esp
  00056	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 440  :     _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 441  :         return static_cast<_Elem>(_Meta);

  00022	0f b6 45 08	 movzx	 eax, BYTE PTR __Meta$[ebp]

; 442  :     }

  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	5b		 pop	 ebx
  00029	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 423  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 424  : #if _HAS_CXX20
; 425  :         if (_STD is_constant_evaluated()) {
; 426  :             return _Primary_char_traits::assign(_Left, _Right);
; 427  :         }
; 428  : #endif // _HAS_CXX20
; 429  :         _Left = _Right;

  00022	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00028	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002a	88 10		 mov	 BYTE PTR [eax], dl

; 430  :     }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 370  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 371  :         // find length of null-terminated string
; 372  : #if _HAS_CXX17
; 373  : #ifdef __cpp_char8_t
; 374  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 375  : #if _HAS_U8_INTRINSICS
; 376  :             return __builtin_u8strlen(_First);
; 377  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 378  :             return _Primary_char_traits::length(_First);
; 379  : #endif // ^^^ no u8 intrinsics ^^^
; 380  :         } else
; 381  : #endif // defined(__cpp_char8_t)
; 382  :         {
; 383  :             return __builtin_strlen(_First);
; 384  :         }
; 385  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 386  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strlen
  0002b	83 c4 04	 add	 esp, 4

; 387  : #endif // ^^^ !_HAS_CXX17 ^^^
; 388  :     }

  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 43   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __39B162D3___msvc_string_view@hpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 44   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 45   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 46   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 47   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 48   : #if _HAS_CXX20
; 49   :         if (_STD is_constant_evaluated()) {
; 50   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 51   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 52   :                 _First1[_Idx] = _First2[_Idx];
; 53   :             }
; 54   : 
; 55   :             return _First1;
; 56   :         }
; 57   : #endif // _HAS_CXX20
; 58   : 
; 59   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00022	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	50		 push	 eax
  00026	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00029	51		 push	 ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _memcpy
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 61   : 
; 62   :         return _First1;

  00036	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 63   :     }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00028	90		 npad	 1
  00029	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	74 0e		 je	 SHORT $LN2@scalar
  00031	6a 0c		 push	 12			; 0000000cH
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  0002c	90		 npad	 1
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00028	90		 npad	 1
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8E23F663_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 143  :         : bad_alloc("bad array new length")

  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc
  00038	90		 npad	 1

; 144  :     {

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004e	3b ec		 cmp	 ebp, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00028	90		 npad	 1
  00029	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	74 0e		 je	 SHORT $LN2@scalar
  00031	6a 0c		 push	 12			; 0000000cH
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0002c	90		 npad	 1
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00028	90		 npad	 1
  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 133  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8E23F663_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 132  :         : exception(_Message, 1)

  0002b	6a 01		 push	 1
  0002d	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00030	50		 push	 eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception
  00039	90		 npad	 1

; 133  :     {

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 134  :     }

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00028	90		 npad	 1
  00029	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	74 0e		 je	 SHORT $LN2@scalar
  00031	6a 0c		 push	 12			; 0000000cH
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  00010	b9 04 00 00 00	 mov	 ecx, 4
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8E23F663_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00032	74 0e		 je	 SHORT $LN3@what
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003a	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv69[ebp], edx
  00040	eb 0a		 jmp	 SHORT $LN4@what
$LN3@what:
  00042	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  0004c	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv69[ebp]

; 97   :     }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8E23F663_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 91   :         __std_exception_destroy(&_Data);

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 04	 add	 eax, 4
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ___std_exception_destroy
  00040	83 c4 04	 add	 esp, 4

; 92   :     }

  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8E23F663_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 72   :         : _Data()

  00034	33 c0		 xor	 eax, eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 04	 add	 ecx, 4
  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 c0 04	 add	 eax, 4
  00047	50		 push	 eax
  00048	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0004b	83 c1 04	 add	 ecx, 4
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ___std_exception_copy
  00054	83 c4 08	 add	 esp, 8

; 75   :     }

  00057	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 67   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __8E23F663_vcruntime_exception@h
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	90		 npad	 1
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 66   :         : _Data()

  00034	33 c0		 xor	 eax, eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 04	 add	 ecx, 4
  0003c	89 01		 mov	 DWORD PTR [ecx], eax
  0003e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 68   :         _Data._What = _Message;

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00047	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 69   :     }

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __3FCAD62E_wchar@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  00022	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00025	d1 e0		 shl	 eax, 1
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 _memcpy
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00038	5f		 pop	 edi
  00039	5e		 pop	 esi
  0003a	5b		 pop	 ebx
  0003b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.42.34433\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 164  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __BCF39F11_vcruntime_new@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1

; 165  :         (void)_Size;
; 166  :         return _Where;

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 167  :     }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\gvent\OneDrive\Desktop\KPO\Lab1\Lab1\Lab1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __490706C5_Lab1@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Users\gvent\OneDrive\Desktop\KPO\Lab1\Lab1\Lab1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __490706C5_Lab1@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	90		 npad	 1
  00022	5f		 pop	 edi
  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
